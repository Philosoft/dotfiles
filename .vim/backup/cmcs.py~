#!/usr/bin/python3

import sys
import os
from optparse import OptionParser

"""Скрипт для приведения коллекции к соответствию с CMCS (Common Music Collection Structure)
На данный момент:
    * создаёт каталог _album_info, если такого нет
    * создаёт каталог _tmp, если такого нет (если по окончании работы каталог пуст, он удаляется)
    * перекладывает в каталог  _album_info все файлы, кроме cue, mp3, ogg, flac, ape и front.jpg
    * перекладывает в каталог _tmp все каталоги, кроме covers, artwork, lyrics, spectrums и logs (их в _album_info)
"""

colours = {
            'none'       :    "",
            'default'    :    "\033[0m",
            'bold'       :    "\033[1m",
            'underline'  :    "\033[4m",
            'blink'      :    "\033[5m",
            'reverse'    :    "\033[7m",
            'concealed'  :    "\033[8m",

            'black'      :    "\033[30m",
            'red'        :    "\033[31m",
            'green'      :    "\033[32m",
            'yellow'     :    "\033[33m",
            'blue'       :    "\033[34m",
            'magenta'    :    "\033[35m",
            'cyan'       :    "\033[36m",
            'white'      :    "\033[37m",

            'on_black'   :    "\033[40m",
            'on_red'     :    "\033[41m",
            'on_green'   :    "\033[42m",
            'on_yellow'  :    "\033[43m",
            'on_blue'    :    "\033[44m",
            'on_magenta' :    "\033[45m",
            'on_cyan'    :    "\033[46m",
            'on_white'   :    "\033[47m",

            'beep'       :    "\007"
            }

parser = OptionParser()
parser.add_option("-v", "--verbose", dest="verbose_flag", help="verbose mode", action="store_true", default=False)
parser.add_option("-V", "--version", dest="ver_flag", help="print version info", action="store_true", default=False)
parser.add_option("-d", "--dest", dest="p", help="destination dir [with music collection]", metavar="/path/to/dir/")
parser.add_option("-s", "--simulate", dest="s", help="simulation mode (do nothing)", action="store_true", default=False)
parser.add_option("-c", "--checksums", dest="c", help="delete existent *.cvf files and replace them with new ones", action="store_true", default=False)

(opts, args) = parser.parse_args()

####### helper functions #######
def verbose(msg):
    '''Выводит сообщения [для отладки], если задан флаг -v'''
    if opts.verbose_flag:
        print(msg)

def color(msg, color):
    '''Возвращает строку разукрашенную в  указанный цвет'''
    return colours[color] + msg + colours['default']
####### helper functions #######

####### functions #######
def print_help():
    '''Выводит информацию о скрипте'''
    print("CMCS script ver", color("0.2", 'green'))

def sort_files(f):
    '''Работает с файлами'''
    src = f
    dst = "_album_info/" + f
    if not opts.s:
        try:
            os.rename(src, dst)
        except OSError as e:
            print(color("ОШИБКА:", 'red'), e.filename + ':', e.strerror)

def work_with_dirs():
    if os.path.exists(os.getcwd() + '/' + "_tmp"):
        pass
    else:
        verbose("  :: Создаём " + color("_tmp", 'red'))
        if not opts.s:
            try:
                os.mkdir("_tmp")
            except OSError as e:
                print(color("ОШИБКА:", 'red'), e.filename + ':', e.strerror)
    if os.path.exists("_album_info"):
        pass
    else:
        # _album_info doesn't exist
        verbose("  :: Создаём " + color("_album_info", 'red'))
        if not opts.s:
            try:
                os.mkdir("_album_info")
            except OSError as e:
                print(color("ОШИБКА:", 'red'), e.filename + ':', e.strerror)

def sort_dirs(d):
    dir = d.lower()
    if dir in ('artwork', 'lyrics', 'covers', 'spectrums', 'logs'):
        verbose("  => Переносим каталог " + d + " в _album_info")
        if not opts.s:
            os.rename(d, "_album_info/" + d)
    else:
        verbose("  => Переносим каталог " + d + " в _tmp")
        if not opts.s:
            os.rename(d, "_tmp/" + d)
####### end of functions #######

if opts.ver_flag:
    print_help()
    sys.exit()

if opts.s:
    opts.verbose_flag = True

if opts.p is None:
    verbose("We will use current [" + os.getcwd() + "] dir")
    opts.p = '.'

if  not os.access(opts.p, os.F_OK and os.X_OK and os.R_OK and os.W_OK):
    verbose("We have not access")
    sys.exit(1)

root = os.path.abspath(opts.p)
exlude_list = ('mp3', 'ogg', 'flac', 'ape', 'cue')

# Ищем исполнителей
list_artists = os.listdir(root)
list_artists.sort()
for artist in list_artists:
    if os.path.isdir(root + '/' + artist):
        # Ищем альбомы
        list_albums = os.listdir(root + '/' + artist)
        list_albums.sort()
        for album in list_albums:
            wp = root + '/' + artist + '/' + album
            if os.path.isdir(wp):
                # Основная часть
                os.chdir(wp)
                verbose("Обрабатываем " + color(os.getcwd(), 'green'))
                # Создаём _album_info и _tmp + если его нет
                work_with_dirs()
                list_files = os.listdir(".")
                list_files.sort()
                for f in list_files:
                    if os.path.isdir(f):
                        if f != "_album_info" and f != "_tmp":
                            sort_dirs(f)
                    elif ((f.lower()).split('.')[-1] in exlude_list) or (f.lower() == "front.jpg"):
                        pass
                    else:
                        sort_files(f)
                verbose("Проверяем осиротевшие файлы")
                try:
                    if os.listdir("_tmp"):
                        print(color('ВНИМАНИЕ:', 'red'), 'не занаю, что делать с:')
                        for orphan in os.listdir("_tmp"):
                            print(orphan)
                    else:
                        verbose("  :: Удаляем " + color("_tmp", 'red'))
                        os.rmdir("_tmp")
                    if os.listdir("_album_info"):
                        pass
                    else:
                        verbose("  :: Удаляем " + color("_album_info", 'red'))
                        os.rmdir("_album_info")
                except OSError as  e:
                    print(color("ОШИБКА", 'red'), e.filename + ':', e.strerror)
                    print("Игнорировать? (y/n)")
                    awnser = raw_input()
                    if awnser == 'y' or awnser == 'Y':
                        pass
                    else:
                        sys.exit(1)
