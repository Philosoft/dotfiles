#!/usr/bin/env python
#*-* coding: utf8 *-*

import pygtk
pygtk.require('2.0')
import gtk
import math

three_d = [[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]]
two_d   = [[0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0]]

one_points = two_points = three_points = military = cabinet = False

class App(gtk.Builder):
    def __init__(self):
        super(App, self).__init__()
        self.add_from_file('gui.ui')
        self.connect_signals(self)
        self.window1.show_all()
        self.da = self.drawingarea1
        self.style = self.da.get_style()
        self.gc = self.style.fg_gc[gtk.STATE_NORMAL]
        self.gc.set_function(gtk.gdk.INVERT)

        self.state = False

        gtk.main()

    def __getattr__(self, attr):
        obj = self.get_object(attr)
        if not obj:
            raise AttributeError('ololo')
        setattr(self, attr, obj)
        return obj

    def quit(self, widget, event):
        gtk.main_quit()

    def mil_cb(self, widget):
        pass
    def cab_cb(self, widget):
        pass

    def rb_cb(self, widget):
        pass

    def draw(self):
        l = int(self.e_d.get_text())
        if self.one_rb.get_active():
            i = 0
            while i < 8:
                two_d[i][0] = round(float(three_d[i][0]) / (1 + float(three_d[i][2]) / float(l)))
                two_d[i][1] = round(float(three_d[i][1]) / (1 + float(three_d[i][2]) / float(l)))
                i += 1
        elif self.two_rb.get_active():
            i = 0
            while i < 8:
                two_d[i][0] = round(float(three_d[i][0]) / ((1 + float(three_d[i][0]) / float(l) + float(three_d[i][2]) / float(l))))
                two_d[i][1] = round(float(three_d[i][1]) / ((1 + float(three_d[i][0]) / float(l) + float(three_d[i][2]) / float(l))))
                i += 1
        elif self.three_rb.get_active():
            i = 0
            while i < 8:
                two_d[i][0] = round(float(three_d[i][0]) /
                                    (1
                                    + float(three_d[i][0]) / float(l)
                                    + float(three_d[i][1]) / float(l)
                                    + float(three_d[i][2]) / float(l)))
                two_d[i][1] = round(float(three_d[i][1]) /
                                    (1
                                    + float(three_d[i][1]) / float(l)
                                    + float(three_d[i][0]) / float(l)
                                    + float(three_d[i][2]) / float(l)))
                i += 1
        elif self.military_rb.get_active():
            i = 0
            while i < 8:
                two_d[i][0] = round(three_d[i][0] - three_d[i][2]*math.cos(0.785))
                two_d[i][1] = round(three_d[i][1] - three_d[i][2]*math.sin(0.785))
                i += 1
        elif self.cabinet_rb.get_active():
            i = 0
            while i < 8:
                two_d[i][0] = round(three_d[i][0] - three_d[i][2]*0.5*math.cos(0.785))
                two_d[i][1] = round(three_d[i][1] - three_d[i][2]*0.5*math.sin(0.785))
                i += 1

        # рисуем
        self.da.window.draw_rectangle(self.style.bg_gc[gtk.STATE_NORMAL], True, 0, 0, 1000, 1000)
        for i in [1, 3, 4]:
            self.da.window.draw_line(self.gc, two_d[0][0], two_d[0][1], two_d[i][0], two_d[i][1])
        for i in [6, 4]:
            self.da.window.draw_line(self.gc, two_d[7][0], two_d[7][1], two_d[i][0], two_d[i][1])
        for i in [1, 4, 6]:
            self.da.window.draw_line(self.gc, two_d[5][0], two_d[5][1], two_d[i][0], two_d[i][1])
        for i in [1, 3, 6]:
            self.da.window.draw_line(self.gc, two_d[2][0], two_d[2][1], two_d[i][0], two_d[i][1])
        self.da.window.draw_line(self.gc, two_d[3][0], two_d[3][1], two_d[7][0], two_d[7][1])


    def moving(self, widget):
        (dx, dy, dz) = (int(self.move_x.get_text()), int(self.move_y.get_text()), int(self.move_z.get_text()))
        i = 0
        self.draw()
        while i < 8:
            three_d[i][0] = three_d[i][0] + dx
            three_d[i][1] = three_d[i][1] + dy
            three_d[i][2] = three_d[i][2] + dz
            i += 1
        self.draw()

    def scaling(self, widget):
        # чтение оотв энтри
        (Sx, Sy, Sz) = (float(self.scale_x.get_text()), float(self.scale_y.get_text()), float(self.scale_z.get_text()))
        (dx, dy, dz) = (three_d[0][0], three_d[0][1], three_d[0][2])
        i = 0
        self.draw()
        while i < 8:
            three_d[i][0] = three_d[i][0] - dx
            three_d[i][1] = three_d[i][1] - dy
            three_d[i][2] = three_d[i][2] - dz #{перемещаем точку][ левая верхняя - в начало координат}

            three_d[i][0] = three_d[i][0] * Sx
            three_d[i][1] = three_d[i][1] * Sy
            three_d[i][2] = three_d[i][2] * Sz  #{масштабируем}

            three_d[i][0] = three_d[i][0] + dx
            three_d[i][1] = three_d[i][1] + dy
            three_d[i][2] = three_d[i][2] + dz  # {перемещаем обратно}
            i += 1
        self.draw()

    def rotate(self, widget):
        (alpha_x, alpha_y, alpha_z) = (float(self.rotate_x.get_text()) * 0.0171,
                                       float(self.rotate_y.get_text()) * 0.0171,
                                       float(self.rotate_z.get_text()) * 0.0171)
        (dx, dy, dz) = (three_d[0][0], three_d[0][1], three_d[0][2])
        (rotate_x, rotate_y, rotate_z) = (self.rx_rb.get_active(), self.ry_rb.get_active(), self.rz_rb.get_active())
        i = 0
        self.draw()
        rotate_x = rotate_z = rotate_y = True
        while i < 8:
            three_d[i][0] = three_d[i][0] - dx
            three_d[i][1] = three_d[i][1] - dy
            three_d[i][2] = three_d[i][2] - dz  #{в цикле перемещаем фигуру в начало координат}
            i += 1
        if rotate_x:
            i = 0
            while i < 8:
                tmp = three_d[i][1]
                three_d[i][1] = tmp*math.cos(alpha_x) - three_d[i][2]*math.sin(alpha_x)
                three_d[i][2] = tmp*math.sin(alpha_x) + three_d[i][2]*math.cos(alpha_x)
                i += 1
        if rotate_y:
            i = 0
            while i < 8:
                tmp = three_d[i][0]
                three_d[i][0] = tmp*math.cos(alpha_y) - three_d[i][2]*math.sin(alpha_y)
                three_d[i][2] = tmp*math.sin(alpha_y) + three_d[i][2]*math.cos(alpha_y)
                i += 1
        if rotate_z:
            i = 0
            while i < 8:
                tmp = three_d[i][0]
                three_d[i][0] = tmp*math.cos(alpha_z) - three_d[i][1]*math.sin(alpha_z)
                three_d[i][1] = tmp*math.sin(alpha_z) + three_d[i][1]*math.cos(alpha_z)
                i += 1
        i = 0
        while i < 8:
            three_d[i][0] = three_d[i][0] + dx
            three_d[i][1] = three_d[i][1] + dy
            three_d[i][2] = three_d[i][2] + dz  #{перемещаем фигуру обратно на место}
            i += 1
        self.draw()

    def read(self, widget):
        d = int(self.length.get_text())
        x = 500 - round(d/2.0)# {тут 365 - середина DrawingArea по иксу][ у тебя свое значение тут будет}
        y = 200 - round(d/2.0)# {соответсвенно 224 - середина по игрику}
        three_d[0][0] = x
        three_d[0][1] = y
        three_d[0][2] = 0
        three_d[1][0] = x+d
        three_d[1][1] = y
        three_d[1][2] = 0
        three_d[2][0] = x+d
        three_d[2][1] = y+d
        three_d[2][2] = 0
        three_d[3][0] = x
        three_d[3][1] = y+d
        three_d[3][2] = 0
        three_d[4][0] = x
        three_d[4][1] = y
        three_d[4][2] = d
        three_d[5][0] = x+d
        three_d[5][1] = y
        three_d[5][2] = d
        three_d[6][0] = x+d
        three_d[6][1] = y+d
        three_d[6][2] = d
        three_d[7][0] = x
        three_d[7][1] = y+d
        three_d[7][2] = d
        self.draw()

a = App()
