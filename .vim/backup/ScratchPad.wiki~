%toc

cope 

= Расписание экзаменов =
| № | Предмет        | Дата       |
|---+----------------+------------|
| 1 | физика         | 03.06.2010 |
| 2 | ОС             | 08.06.2010 |
| 3 | ЛПО            | ---------- |
| 4 | Электротехника | 18.06.2010 |
| 5 | Тервер         | 24.06.2010 |

= Отступы в VIM =
Процесс смены Komodo IDE на VIM я начал с изучения всевозможных туториалов и хау ту, однако, что удивительно, ни в одном из них мне не удалось встретить человеческого описания процесса настройки отступов. В одних предлагали регулировать ширину отступа с помощью опции tabstop, в других — с помощью softtabstop, в третьих — выставлять и то и другое и shiftwidth в придачу. После нескольких часов экспериментов с настройками я понял, что единственный способ не только заставить все работать, но и понять, почему оно работает — читать документацию. Своими «открытиями» я и хочу с вами поделиться.

Начну с описания опций, которые могут использоваться при настройке отступов.

*tabstop* (по умолчанию 8) — количество пробелов, которыми символ табуляции отображается в тексте. Оказывает влияние как на уже существующие табуляции, так и на новые. В случае изменения значения, «на лету» применяется к тексту.

*softtabstop* (0) — количество пробелов, которыми символ табуляции отображается при добавлении. Несмотря на то, что при нажатии на Tab вы получите ожидаемый результат (добавляется новый символ табуляции), фактически в отступе могут использоваться как табуляция так и пробелы. Например, при установленных tabstop равной 8 и softtabstop равной 4, троекратное нажатие Tab приведет к добавлению отступа шириной 12 пробелов, однако сформирован он будет из одного символа табуляции и 4 пробелов.

*shiftwidth* (8) — по умолчанию используется для регулирование ширины отступов в пробелах, добавляемых командами >> и <<. Если значение опции не равно tabstop, как и в случае с softtabstop, отступ может состоять как из символов табуляций так и из пробелов. При включении опции — smarttab, оказывает дополнительное влияние.

*smarttab* (выключена) — в случае включения этой опции, нажатие Tab в начале строки (если быть точнее, до первого непробельного символа в строке) приведет к добавлению отступа, ширина которого соответствует shiftwidth (независимо от значений в tabstop и softtabstop). Нажатие на Backspace удалит отступ, а не только один символ, что очень полезно при включенной expandtab. Напомню: опция оказывает влияние только на отступы в начале строки, в остальных местах используются значения из tabstop и softtabstop.

*expandtab* (выключена) — в режиме вставки заменяет символ табуляции на соответствующее количество пробелов. Так же влияет на отступы, добавляемые командами >> и <<.

Вооружившись полученными знаниями, очень просто настроить требуемое поведение отступов. Популярная практика у разработчиков: пробелы вместо табуляции, ширина отступа — 4 пробела. Настройка в данном случае будет выглядеть следующим образом:
{{{set tabstop=4
set shiftwidth=4
set smarttab
set expandtab}}}

На десерт я оставил описание двух life changing опций для тех, кто использует VIM в качестве редактора для разработки:

autoindent (выключена) — копирует отступы с текущей строки при добавлении новой.

smartindent (выключена) — делает то же, что и autoindent плюс автоматически выставляет отступы в «нужных» местах. В частности, отступ ставится после строки, которая заканчивается символом {, перед строкой, которая заканчивается символом }, удаляется перед символом #, если он следует первым в строке и т.д. (подробнее help 'smartindent').

Вот, собственно, и все.

Мой конфигурационный файл в части отступов выглядит следующим образом:
{{{set tabstop=4
set shiftwidth=4
set smarttab
set expandtab
set smartindent
}}}

= Скопированно у rain'a =

== "Прицельная" рекурсивная замена чего-либо в файлах ==
Материал из Linux Wiki
Перейти к: навигация, поиск

Скрипт для рекурсивной замены какой-либо строки, попадающей под регулярное выражение, в файлах в указанной директории.

    * target задает то, на что надо заменять строку или часть строки.
    * source задает регулярное выражение, по которому надо отсеивать нужные строки
    * directory/ задает каталог, в котором производится поиск 

Принцип работы
    grep делает рекурсивный поиск в файлах, исключая бинарники по регулярному выражению, описываему в source, игнорируя регистр и выдает строку в формате "файл:номер строки:выражение, описываемое source". Данная строка обрабатывается awk'ом, который заменяет двоеточие на пробел и выводит строку в виде "файл номер_строки вся_строка". Строка передается циклу, где от 3-го параметра (т.е., всей строки) отрезается выражение, описываемое source. После этого sed делает замену $what на $to только лишь для строки $string для данного файла. 

Примечание
    grep и sed в данном скрипте игнорирует регистр букв в выражениии, если это не нужно - убрать i в ключах grep и в командах sed. 
{{{class="brush: bash"
to='target'
grep --color -oiIrn "source" directory/ | awk -F':' '{print $1, $2, $0}' |
while read file string all
	do
	what=$(echo "${all}" | cut -d: -f3-)
	sed -i -e "${string}s@${what}@${to}@gi" "${file}"
done
}}}

== Обновление кодека и метаинформации для FLAC-файлов ==
Материал из Linux Wiki
Перейти к: навигация, поиск

Скрипт для обновления версии кодека и метатегов в FLAC-файлах (к примеру, надо обновить кодек с v.1.1.0 до v.1.2.1 либо создать seektable для файлов, если, к примеру, есть проблемы с проматыванием трека в Amarok). Указываем каталог, где лежат FLAC-файлы либо указываем нужные файлы как параметры скрипта, для каждого из них скрипт декодирует и одновременно кодирует получившийся поток в файл с расширением new, считывает теги из старого и записывает в новый файл, потом перемещает новый файл на место старого.

{{{class="brush: bash"
#!/bin/bash
# By Rain ;)
 
updatefile() {
        echo -e "\n\e[35mWorking on file \e[36m${1}\e[0m"
        flac -sdc "${1}" | flac --best - -Vo "${1}.new"                 &&\
        metaflac --export-tags-to=- "${1}" | metaflac --import-tags-from=- "${1}.new" &&\
        mv "${1}.new" "${1}"
}
 
if [ -z "${1}" ]
        then
                find ./ -iname '*.flac' |
                while read file
                do
                        updatefile "${file}"
                done
else
        for file in "${@}"
                do
                        updatefile "${file}"
                done
fi
}}}

== Отправка статистики на last.fm для MOC ==
Материал из Linux Wiki
Перейти к: навигация, поиск

Для работы требует настроенный lastfmsubmitd. В конфигурационном файле необходимо изменить параметр OnSongChange на

OnSongChange            = "/home/rain/.moc/mocsubmit.sh "%a" "%r" "%t" "%d" &"

заменить имя пользователя и путь к скрипту на свое

Если в течение 15 секунд все еще продолжает играть та же песня - статистика отправляется на last.fm. Баги: если быстро переключиться на другую песню, а потом снова на первую либо просто несколько раз запустить воспроизведение одной и той же песни - будут засчитаны лишние сабмиты.

В дополнение, скрипт позволяет организовать остановку воспроизведения после проигрывания текущей композиции. Для этого добавьте в конфигурационный файл строки:

ExecCommand1            = "touch /home/rain/.moc/sacs.lock"
ExecCommand2            = "rm -f /home/rain/.moc/sacs.lock"

Пути заменить на свои. По F1 включается режим остановки, по F2 - отключается. Баги: если по какой-то причине файлик при запуске плеера уже был (как вариант - была включена остановка на последнем треке в плейлисте) - воспроизведение остановится после первой же композиции

{{{class="brush: bash"
#!/bin/bash
# By Rain ;)
 
if [ -e "${HOME}/.moc/sacs.lock" ]; then
        mocp -s
        rm -f "${HOME}/.moc/sacs.lock"
        exit 0
fi
 
if [ ! -x /usr/lib/lastfmsubmitd/lastfmsubmit ]
        then
        echo 'Error: /usr/lib/lastfmsubmitd/lastfmsubmit not found'
        exit 1
fi
 
sleep 15
 
if [ "${1}${3}${2}" == "$(mocp -i | awk -F': ' '/^Artist|^Album|^SongTitle/{print $2}' | tr -d '\n')" ]
        then
        /usr/lib/lastfmsubmitd/lastfmsubmit --encoding "UTF8" --artist "${1}" --title "${3}" --length "${4}" --album "${2}"
fi
}}}

== Перекодирование одиночного lossless аудиофайла во FLAC по CUE-таблице ==
Материал из Linux Wiki
Перейти к: навигация, поиск

Скрипт для преобразования одиночного файла, представляющего собой копию диска в отдельные FLAC-файлы с заполнением тегов и именованием файлов в соответствии с CUE-таблицой

    * Работает с файлами в формате APE, WavPack, FLAC, WAV, ALAC
    * В случае отсутствия CUE-файла просто конвертирует входной файл во FLAC
    * Конвертирует CUE с национальными символами в utf-8 с использованием enca (автоматически определяет кодировку)
    * Заполняет теги в выходных файлах из CUE
    * Умеет экспортировать CUE, встроенный во FLAC-файл, после чего делает нарезку/заполнение тегов по этому CUE (если принудительно не указан внешний файл)
    * Автоматически определяет тип файла по MIME-type
    * Может обрабатывать входной файл двумя способами - стандартными утилитами для каждого формата (опция direct=0) с последующей нарезкой и напрямую средствами shnsplit (кроме формата WavPack, он в любом случае сначала конвертируется в WAV). 

Использование
    anycue2flac "AUDIO FILE.ape" "TEXT FILE.cue" 
Зависимости
    flac, shntool, cuetools, enca, monkeys-audio, wavpack, alac (в зависимости от того, с какими файлами надо будет работать) 

ToDo: Избавиться от хардлинка, проверить, что все работает, сделать обработку для файлов высокого разрешения (проходиться sed'ом по cue)

{{{class="brush: bash"
#!/bin/bash
# By Linuxoid Project. Authors: Rain, AntiChrist.
 
direct='1'
outdir="$HOME/Music/"
tempfile="$(date +tempfile.%s)"
tempcue="$(mktemp).cue"
 
help() {
 echo -e "\e[1;34mИспользование:
\t\e[1;32m$(basename $0) \e[1;33m\"Звуковой_файл (ape, flac и т.д.)\" \e[1;33m\"Таблица_Дорожек.cue\"\e[0m\n";
 
 echo -e "\e[1;31mЗависимости\e[0m, необходимые для работы:\e[1;32m
\tflac
\tshntool
\tcuetools
\tenca\e[0m
"
 
 echo -e "\e[1;33mДополнительно \e[0;33m(в зависимости от типов конвертируемых файлов)\e[0m:
\t\e[1;32mmonkeys-audio \e[0;34m(Семейство Debian/*untu)\e[0m или \e[1;32mmac \e[0;34m(Остальные дистрибутивы)\e[0m
\t\e[1;32mwavpack\e[0m
\t\e[1;32malac_decoder\e[0m \e[34m(При отсутствии пакета в дистрибутиве качать отсюда: \e[36mhttp://craz.net/programs/itunes/alac.html\e[34m)\e[0m\n";
 
 echo -e "\e[1;32mРезультат конвертации ищите в директории \e[36m$outdir\e[1;32m.
\t\e[0;32mЕсли хотите изменить путь сохранения - запускайте скрипт, как
\t\e[1;36mHOME='/путь/к/новому/месту' \e[1;32m$(basename $0) \e[1;33m[параметры]\e[0m.
\t\e[32mИли же измените переменную \e[1;36moutdir \e[0;32mвнутри скрипта.\e[0m\n"
}
 
error() {
echo -e "\e[1;31m${1}\e[0m"
exit $2
}
 
ch_utils() {
uts='';
uts=$uts"$@";
	test $(which flac 2>/dev/null) ||  uts=$uts' flac'
	test $(which shnsplit 2>/dev/null) || uts=$uts' shntools'
	test $(which enconv 2>/dev/null) || uts=$uts' enca'
	test $(which cueprint 2>/dev/null) || uts=$uts' cuetools'
if [[ $uts != '' ]]
	then
		echo -e "\e[1;31mУстановите, пожалуйста, следующие пакеты:"
	for i in ${uts}
		do
			echo -e "\e[1;32m$i"
	done
	echo -e "\e[1;31mОни необходимы для работы скрипта.\e[0m"
	exit 1
fi
}
 
tag() {
cf="$1"
shift
TN=1
n=$(cueprint -d '%N' "$cf")
	if [ $# -ne $n ]; then
		echo -e "\e[1;31mВнимание\e[0m: Количество получившихся файлов не соответствует количеству треков в исходном файле."
	fi
fields='TITLE VERSION ALBUM TRACKNUMBER TRACKTOTAL ARTIST PERFORMER COPYRIGHT LICENSE ORGANIZATION DESCRIPTION GENRE DATE LOCATION CONTACT ISRC ARRANGER'
	TITLE='%t'
	VERSION=''
	ALBUM='%T'
	TRACKNUMBER='%n'
	TRACKTOTAL='%N'
	ARTIST='%c %p'
	PERFORMER='%p'
	COPYRIGHT='FMD'
	LICENSE='CC'
	ORGANIZATION=''
	DESCRIPTION='%m'
	GENRE='%g'
	DATE=''
	LOCATION=''
	CONTACT=''
	ISRC='%i %u'
	ARRANGER=''
 
year="$(grep '^REM DATE' "${cf}" | grep -oE '[0-9]{4}')"
 
for file in "$@"; do
	(for field in $fields; do
		value=""
		for conv in `eval echo \\$$field`; do
			value=$(cueprint -n "$TN" -t "$conv\n" "$cf")
			if [ -n "$value" ]; then
				echo -e "$field=${value}"
				break
			fi
		done
	done) | metaflac --remove-all-tags --import-tags-from=- "$file"
metaflac --set-tag DATE="${year}" "${file}"
TN=$(($TN + 1))
done
}
# Сам скрипт
# Проверка передачи нужного числа параметров
if [ "${#}" -lt 1 ] || [ "${#}" -gt 2 ]; then
	help
	exit
fi
 
# Проверка наличия необходимых утилит
ch_utils;
 
# Проверка формата входного файла и проверка наличия декодеров
if [[ "$(file -b "${1}")" =~ "Monkey's Audio" ]]; then
	test $(which mac 2>/dev/null) || ch_utils "monkeys-audio \e[1;34m(Семейство Debian/*untu)\e[0m или \e[1;32mmac \e[1;34m(Остальные дистрибутивы)\e[0m"
		fileformat='APE'
		echo -e "\e[35mФормат файла - \e[36mMonkey's Audio \e[35m(\e[36mAPE\e[35m)\e[0m\n"
 
elif [[ "$(file -b "${1}")" =~ "iTunes AAC-LC" ]]; then
		test $(which alac)	|| ch_utils "alac_decoder (запустите скрипт без параметров для справки)"
		if [ "$(alac -t "${1}" 2>/dev/null)" == 'file type: alac' ]; then
			fileformat='ALAC'
			echo -e "\e[35mФормат файла - \e[36mApple Lossless Audio Codec \e[35m(\e[36mALAC\e[35m)\e[0m\n"
		else
			error "Формат файла M4A, но он не является ALAC. Перекодировка невозможна." 1
		fi
 
elif    [[ "$(file -b "${1}")" =~ "FLAC audio" ]]; then
		fileformat='FLAC'
		echo -e "\e[35mФормат файла - \e[36mFree Lossless Audio Codec \e[35m(\e[36mFLAC\e[35m)\e[0m\n"
 
elif    [[ "$(file -b "${1}")" =~ "WAVE audio" ]]; then
		fileformat='WAV'
		echo -e "\e[35mФормат файла - \e[36mWAVE\e[0m\n"
 
elif    [ "${1##*.}" == 'wv' ]; then
		test $(which wvunpack)  || ch_utils "wavpack"
		fileformat='WV'
		echo -e "\e[35mФормат файла - \e[36mWavPack\e[0m\n"
 
else
	error "Неизвестный формат входного аудио-файла \"${1}\" (возможно, работа с этим форматом еще не добавлена в скрипт)." 1
fi
 
# Проверка наличия внешнего или встроенного CUE-файла
if [ ! -z "${2}" ]; then
	cuefile="${tempcue}"
	cat "${2}" | enconv > "${cuefile}"
	outdir="${outdir}/$(cueprint "${cuefile}" -t "%P/\n"|uniq)$(grep '^REM DATE' "${cuefile}" | grep -oE '[0-9]{4}' | sed -r 's/[0-9]{4}/& - /g')$(cueprint "${cuefile}" -t "%T\n"|uniq)"
else
	if [ "${fileformat}" == 'FLAC' ]; then
		if [ "$(metaflac --list "${1}" | grep -qi cuesheet && echo 1)" ]; then
			echo -e "\e[1;32mНайдена CUE-таблица внутри файла... Извлекаем...\e[0m"
			cuefile="${1%.*}.cue"
			metaflac "${1}" --export-tags-to=- | sed -e 's/CUESHEET=//g' -n -e '/^ *$/,//!p' > "${tempcue}"
			cat "${tempcue}" | enconv > "${cuefile}"
			outdir="${outdir}/$(cueprint "${cuefile}" -t "%P/\n"|uniq)$(grep '^REM DATE' "${cuefile}" | grep -oE '[0-9]{4}' | sed -r 's/[0-9]{4}/& - /g')$(cueprint "${cuefile}" -t "%T\n"|uniq)"
		else
			echo -e "\e[1;33mCUE-таблица не задана и не найдена в файле.\nКонвертируем ${1} в FLAC без разбивки на треки...\e[0m\n"
			direct='0'
			outdir="${outdir}/without_cue"
		fi
	else
		echo -e "\e[1;33mCUE-таблица не задана и не найдена в файле.\n\e[0;35mКонвертируем \e[36m${1}\e[35m в \e[36mFLAC\e[35m без разбивки на треки.\e[0m\n"
		direct='0'
		outdir="${outdir}/without_cue"
	fi
fi
 
# Создание каталога назначения и имени временного файла
if [ -e "$outdir" ]; then
	echo -e "\e[1;31mВнимание: каталог \e[1;34m${outdir} \e[1;31mуже существует.
Возможно там находятся результаты предыдущей перекодировки этого альбома.\e[0m\n"
else
	echo -e "\e[35mСоздаем каталог \e[36m${outdir}\e[35m,\nв который мы будем складывать переконвертированные файлы...\e[0m\n"
fi
mkdir -p "${outdir}"
 
# Декодирование файлов в случае пошаговых операций
if [ "${direct}" == '0' ]; then
	case "${fileformat}" in
		APE)
			echo -e "\e[35mКонвертирование \e[36m"${1}"\e[35m из \e[36m"${fileformat}"\e[35m в \e[36mWAV\e[35m...\e[0m\n"
			mac "${1}" "${outdir}/${tempfile}.wav" -d
		;;
		ALAC)
			echo -e "\e[35mКонвертирование \e[36m"${1}"\e[35m из \e[36m"${fileformat}"\e[35m в \e[36mWAV\e[35m...\e[0m\n"
			alac -f "${outdir}/${tempfile}.wav" "$1"
		;;
		FLAC)
			echo -e "\e[35mКонвертирование \e[36m"${1}"\e[35m из \e[36m"${fileformat}"\e[35m в \e[36mWAV\e[35m...\e[0m\n"
			flac -d "${1}" -o "${outdir}/${tempfile}.wav"
		;;
		WAV)
			echo -e "\e[36m${1} \e[35mготов к обработке, создаем ссылку в \e[36m${outdir}\e[0m\n"
			ln "${1}" "${outdir}/${tempfile}.wav"
		;;
		WV)
			echo -e "\e[35mКонвертирование \e[36m"${1}"\e[35m из \e[36mWavPack\e[35m в \e[36mWAV\e[35m...\e[0m\n"
			wvunpack -m "${1}"
			mv "${1%.*}.wav" "${outdir}/${tempfile}.wav"
		;;
	esac
else
	case "${fileformat}" in
		WV)
			echo -e "\e[35mКонвертирование \e[36m"${1}"\e[35m из \e[36mWavPack\e[35m в \e[36mWAV\e[35m...\e[0m\n"
			wvunpack -m "${1}"
			mv "${1%.*}.wav" "${outdir}/${tempfile}.wav"
		;;
		ALAC)
			echo -e "\e[35mКонвертирование \e[36m"${1}"\e[35m из \e[36m"${fileformat}"\e[35m в \e[36mWAV\e[35m...\e[0m\n"
			alac -f "${outdir}/${tempfile}.wav" "$1"
		;;
		*)
			ln "${1}" "${outdir}/${tempfile}.${1##*.}"
		;;
	esac
fi
 
 
if [ -z "${cuefile}" ]; then
# Кодирование WAV-файла в FLAC в случае отсутствия CUE
	echo -e "\n\e[35mКонвертация \e[36m${1}\e[35m в \e[36mFLAC\e[0m"
	flac --delete-input-file --best -V "${outdir}/${tempfile}.wav" -o "${outdir}/${1%.*}.flac"
else
	echo -e "\e[35mРазрезаем \e[36m"${1}" \e[35mпо композициям на отдельные FLAC-файлы...\e[0m\n"
	cd "${outdir}";
# Нарезка входного файла на треки
	cat "$cuefile" | shnsplit -o 'flac ext=flac flac --best -V - -o %f' -t "%n - %t" "${tempfile}"*
# Удаление временного файла
	rm -f "${tempfile}"*
# Удаление pregap-файла
	rm -f 00*pregap*.flac
	echo -e "\n\e[35mПрописываем теги в файлы...\e[0m"
# Заполнение тегов
	tag "$cuefile" *.flac
# Удаление ненужного CUE
	rm -f "${cuefile}" "${tempcue}"
fi
 
exit 0
}}}

== Поиск дубликатов треков в сборниках по альбомам ==
Материал из Linux Wiki
Перейти к: навигация, поиск

Простая функция для поиска подобных треков по именам в дискографиях. В качестве параметра передается каталог, для которого будет выполняться анализ; поиск происходит в соседних каталогах.
ToDo: Сделать удаление незначащих символов
{{{class="brush: bash"
findcoll() {
ls -1 "${1}"/*.flac |
while read file
do
name="$(basename "$file")"
num="$(echo $name | cut -b-4)"
name="${name%.*}"
find . -type f -iname "*${name#* }*.flac" -exec ls -lh {} \; | sed "s/^/$num/g" | sort -k6
echo ----------------------------------------------------------------
done
}
}}}
Пример использования:
{{{
rain@acnote:/mnt/music/flac/Sting$ findcoll 2003\ -\ Brand\ New\ Day/
01 --rw-rw-r-- 1 root root 37M Сен 20 21:27 ./2000 - Collection 2000/01 - A Thousand Years.flac
01 --rw-rw-r-- 1 root root 68M Окт 16 17:30 ./2003 - Brand New Day/01 - A Thousand Years.flac
----------------------------------------------------------------
02 --rw-rw-r-- 1 root root 34M Сен 20 21:27 ./2000 - Collection 2000/15 - Desert Rose.flac
02 --rw-rw-r-- 1 root root 57M Окт 17 09:54 ./2003 - Brand New Day/02 - Desert Rose.flac
----------------------------------------------------------------
03 --rw-rw-r-- 1 root root 59M Окт 17 09:55 ./2003 - Brand New Day/03 - Big Lie Small World.flac
----------------------------------------------------------------
04 --rw-rw-r-- 1 root root 60M Окт 16 17:30 ./2003 - Brand New Day/04 - After The Rain Has Falled.flac
----------------------------------------------------------------
05 --rw-rw-r-- 1 root root 59M Окт 16 17:30 ./2003 - Brand New Day/05 - Perfect Love... Gone Wrong.flac
----------------------------------------------------------------
06 --rw-rw-r-- 1 root root 53M Окт 16 17:30 ./2003 - Brand New Day/06 - Tomorrow We'll See.flac
----------------------------------------------------------------
07 --rw-rw-r-- 1 root root 2,2M Окт 16 17:30 ./2003 - Brand New Day/07 - Prelude To The End Of The Game.flac
----------------------------------------------------------------
08 --rw-rw-r-- 1 root root 64M Окт 16 17:30 ./2003 - Brand New Day/08 - Fill Her Up.flac
----------------------------------------------------------------
09 --rw-rw-r-- 1 root root 62M Окт 16 17:30 ./2003 - Brand New Day/09 - Ghost Story.flac
----------------------------------------------------------------
10 --rw-rw-r-- 1 root root 146M Окт 16 17:30 ./2003 - Brand New Day/10 - Brand New Day.flac
10 --rw-rw-r-- 1 root root 41M Сен 20 21:27 ./2000 - Collection 2000/10 - Brand New Day.flac
----------------------------------------------------------------
}}}

== Поиск и исправление FLAC-файлов с некорректными метаданными ==
Материал из Linux Wiki
Перейти к: навигация, поиск

Этот небольшой скрипт найдет все FLAC-файлы в аудиоколлекции, в которых:

    * отсутствует SEEKTABLE (из-за этого, например, в amarok может не работать перемотка на треке)
    * устаревший кодек (не соответствует указанной в скрипте версии)
    * битая строка, в которой указывается тип и версия кодека (на таких файлах, возможно, вешается easytag) 
{{{class="brush: bash"
find ./ -iname \*.flac |
while read file
do
metaflac="$(metaflac --list "${file}")" && \
[[ "$(grep -q 'reference libFLAC 1.2.1' <<< $metaflac && echo 1)" == '1' && "$(grep -q 'SEEKTABLE' <<< $metaflac && echo 1)" == '1' ]] || echo ${file%/*}
done | sort -u
}}}

Скрипт выдаст список альбомов/каталогов, в которых встречаются "битые" файлы, после чего каждый альбом можно будет обработать скриптом для обновления кодека и метаданных (возможно позже я сделаю, чтобы тот скрипт мог обрабатывать отдельные файлы, тогда в этом можно будет делать вывод не целого альбома, а только нужных файлов... А пока так, для надежности :))

{{{
 | while read album ; do cd "${album}" ; flacupdate.sh ; cd - ; done
}}}

== Получение текстов песен в MOC ==
Материал из Linux Wiki
Перейти к: навигация, поиск

Скрипт работает с http://lyricwiki.org и по нажатию F3 показывает текст проигрывающейся песни.

Допущение: первые буквы каждого слова в имени артиста / названии песни преобразуются в верхний регистр - похоже, такое именование принято на вики.

Строка в конфиг-файле (путь к скрипту указать свой):
{{{
ExecCommand3            = "/home/rain/.moc/scripts/lyrc.sh "%r" "%t""
}}}
{{{class="brush: bash"
#!/bin/bash
clear
echo "Fetching lyrics..."
wget -q "http://lyricwiki.org/$(mocp -i | awk -F': ' '/Artist/||/SongTitle/{print $2}' | sed -e 'N; s/\n/:/g' | sed -r -e 's/(\s|^)\b(.)/\1\U\2/g')" -O - |
sed -n -e '/<div class='\''lyricbox'\'' >/s/.*<div class='\''lyricbox'\'' >//gp' |
sed -e "s@<br />@\n@g" -e 's/\&amp\;/\&/g'| less
}}}

== Простая конвертация APE-файла во FLAC ==
Материал из Linux Wiki
Перейти к: навигация, поиск

{{{class="brush: bash"
mac2flac() {
filename="${1}"
shift
mac "${filename}" - -d | flac "${@}" --best - -Vso "${filename%.???}.flac"
}
}}}
В качестве первого параметра указывается имя APE-файла, остальные параметры напрямую передаются команде flac. Пример:
{{{
mac2flac 01-Un\ Dia\ Sin\ Ti.ape -T ARTIST="Roxette" -T ALBUM="Baladas en Espanol" -T TITLE='Un Dia Sin Ti (Spending My Time)' -f
}}}

== Рекурсивная замена пробелов на подчеркивания в именах файлов и каталогов ==
Материал из Linux Wiki
Перейти к: навигация, поиск

Скрипт позволяющий заменять пробелы на подчеркивание в именах файлов.
{{{class="brush: bash"
find path1 path2 -type f | while read full   # find - ищет файлы в указанном пути, while - осуществляет
do                                           # циклическое действие
name=${full##*/}                             # вырезаем имя файла, функция убирает все до последнего слеша "/",
mv -- "${full}" "${full%/*}/${name// /_}"    # оставляя только имя файла
done                                         # перемещаем старый файл (полное имя которого в переменной full) в
                                             # новый, образованный 
                                             # именем файла (переменная name, в которой сделана замена пробела на _)
                                             # и путем
                                             # к нему (получен методом обрезания полного имени файла до первого
                                             # леша)
}}}

Скрипт для работы с директориями в процессе разработки.

=== Скачивание файлов через удаленный сервер без прокидывания портов ===
Материал из Linux Wiki
Перейти к: навигация, поиск

Вариант закачивания файлов с использованием удаленных серверов (практически любого количества) по SSH без использования прокидывания портов или настройки прокси-серверов. Если нет авторизации по ключам - добавить -t в первом случае, но тогда не будет прогресс-бара от wget'a. Если указан не веб-адрес (не http или ftp) - идет скачивание файла на удаленном сервере (например, getremotely /home/vasya/file123).

{{{class="brush: bash"
getremotely() {
[[ "${1%%:/*}" == 'http' || "${1%%:/*}" == 'ftp' ]] && cmd='wget -O -' || cmd='cat'
ssh -C user1@host1 "ssh -C user2@host2 '${cmd} "${1}"'" > "${1##*/}"
echo 'Download complete'
}
}}}

==Таблица кодов цветов в терминале ==
Материал из Linux Wiki
Перейти к: навигация, поиск

Небольшой скрипт для вывода управляющих Esc-последовательностей для раскрашивания текста в терминале.

Использование управляющих последовательностей
{{{    echo -e "\e[5;31mТЕКСТ\e[0m" выдаст мигающее слово "ТЕКСТ" красного цвета. Последовательность \e[0m возвращает терминал к исходному состоянию. }}}

{{{class="brush: bash"
printf "%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n" $(
for i in {0..128}
do
	echo -ne "\e["$i"mКод${i}\e[0m "
done)
}}}

== Часы в терминале ==
Материал из Linux Wiki
Перейти к: навигация, поиск

Скрипт, рисующий часы в терминале. Где взял - не помню, но выглядит прикольно :). Решил выложить, чтобы не потерялся у меня в хламе.
{{{class="brush: bash"
#!/bin/bash
 
#       Clock in terminal by olecom. Idea by pulsar.
#       Additional push from unDEFER.
 
## SYNOPSIS:
#          ./clock.sh [delay | [-h | --help]]
##                    in seconds, default delay is 1 second.
##
#
# WARNING ! Run in pure BaSH, then mc & others.
# FEATURES: In xterm mode after 'top' it needs to
#           be 'clear' or 'tput clear' manually.
#           May be some other programs need that.
#
# --
# You may feel free to e-m@il me:
# $(echo "_olecomXflowerYupolZcz~" | tr _XYZ~ "<\100..>")
##
# * started in october 2002
# * reduced in plugin Wed Nov 27 06:09:01 EET 2002
# * good changes      Wed Dec  1 11:30:22 CET 2004
#
## $Id: clock.sh,v 1.4 2005/03/14 21:35:12 olecom Exp $
#
 
# featured echo, handles tty's existence, else kill itself
Echo() {
    if [ -w $OUT_TTY ]
    then echo -en $@ >$OUT_TTY || kill $$
    else kill $$
    fi
}
 
# trap on many SIGnals, that may be send here to kill us ;-)
clock_deinit() {
    # we are need to reset origin tty
    stty --file $OUT_TTY rows $ROWS
    # finalize resetting tty, here's setting of scrolling
    # region and making cursor position depend on that
    Echo "\E[1;"$ROWS"r"
    Echo "\E[?6h"
#    tput clear >$OUT_TTY
    Echo "Clock was successfully killed."
 
    exit 0
}
 
clock_init() {
    # global
    OUT_TTY=$1
    ROWS=$3
    COLS=$(( $(($4))/2 - 15 ))
 
    # below may be fanything
    TOP[1]="******"
    TOP[2]="L*****"
    TOP[3]="*i****"
    TOP[4]="**n***"
    TOP[5]="***u**"
    TOP[6]="****x*"
    TOP[7]="Debian"
    TOP[8]="GNU + "
    TOP[9]="Linux!"
    STRNUM=$((9 + 1))
    i=1
}
 
# Arguments:
# $1 - tty; $2 - delay, for slow connections; $3 - rows; $4 - cols;
term_linux_clock_run() {
    # common init
    clock_init $@
    # msg
    Echo "\n
BaSH Clock is active. Linux text mode.\n
It automaticaly quits on _terminal_ exit.\n
Or use 'kill $$'\n
\n
"
    # inf loop
    while [ 1 ]
    do
	#current row: Echo "\E7\E[1;32;40m\E[0G[$(date +%X)]<${TOP[$i]}>\E8"
	#rows, cols-17, atomic execution
        Echo "\E7\E[1;32;40m\E[$3;$(($4 - 17))H[$(date +%X)]<${TOP[$i]}>\E8"
	i=$((++i))
	if [ $STRNUM -eq $i ]
	then
	    i=1
	fi
 
	sleep $2
    done
}
 
# Arguments:
# $1 - tty; $2 - delay, for slow connections; $3 - rows; $4 - cols;
term_xterm_clock_run() {
    # common init
    clock_init $@
 
    # handling of killing
    trap "clock_deinit" 1 2 3 9 15
 
    # msg
    Echo "\n
BaSH Clock is active. XTerm mode.\n
It automaticaly quits on _terminal_ exit.\n
Or use 'kill $$'\n
\n
"
    # inf loop
    while [ 1 ]
    do
	# handling of resizing of xterm
	SIZE=($(stty --file $OUT_TTY size))
	if [ $ROWS -ne $(( ${SIZE[0]} + 1)) ]
	then
	    ROWS=${SIZE[0]}
	    # set tty
	    stty --file $OUT_TTY rows $(( $ROWS - 1 ))
	    # finalize tty
	    Echo "\E[1;$(( $ROWS - 1 ))r"
	fi
 
	# atomic execution of output
	D=$(date +%X)
        Echo "\E7\E[1;32;40m\E[$ROWS;$(($COLS))H[$D]<${TOP[$i]}>[$D]\E8"
	i=$((++i))
	if [ $STRNUM -eq $i ]
	then
	    i=1
	fi
 
	sleep $2
    done
}
 
##** main() **##
 
## Help checking
if [ "$1" = -h -o "$1" = --help ]
then
    echo "##
#       Clock in terminal by olecom. Idea by pulsar.
#       Additional push from unDEFER.
## SYNOPSIS:
#          clock.sh [delay | [-h | --help]]
##                  in seconds, default delay is 1 second.
##
#
# WARNING ! Run in pure BaSH, then mc & others.
# FEATURES: In xterm mode after 'top' it needs to
#           be 'clear' or 'tput clear' manually.
#           May be some other programs need that.
#
# --
# You may feel free to e-m@il me:
# $(echo "_olecomXflowerYupolZcz~" | tr _XYZ~ "<\100..>")
##"
    exit 0
fi
 
## mc detection
# find parent of our bash
PPPID=($(ps -o pid,ppid,comm | grep bash))
# if it is mc, then exit 1
if [ "$(ps h -o comm ${PPPID[1]})" = "mc" ]
then
    echo -e "Do not run this under mc !\nRead --help."
    exit 1
fi
 
 
# if not forked
if [ -z $4 ]
then 
    # initial
    OUT_TTY=$(tty)
    SIZE=($(stty size))
    ROWS=${SIZE[0]}
    COLS=${SIZE[1]}
 
    # delay is a digit, integer or real
    if [ -z $1 ]
    then DELAY=1
    else
        if [ "$(echo $1 | sed s/\[\.0123456789\]//g)" ] 
        then
            DELAY=1
        else
            DELAY=$1
        fi
    fi
 
    if [ $TERM = linux ]
    then
	# fork
	$0 $OUT_TTY $DELAY $ROWS $COLS 2>&1 1>/dev/null &
    else
	# setting up tty with rows--
	stty rows $(( $ROWS - 1 ))
	# finalize setting up tty, here's setting scrolling region
	echo -en "\E[1;$(( $ROWS - 1 ))r"
	tput clear
	# fork
	$0 $OUT_TTY $DELAY $ROWS $COLS 2>&1 1>/dev/null &
#debug:	$0 $OUT_TTY $DELAY $ROWS $COLS
    fi
else 
#do the job
    if [ $TERM = linux ]
    then
	term_linux_clock_run $@
    else
	term_xterm_clock_run $@
    fi
fi
}}}

чтобы не запускать каждый раз, можно воспользоваться услугами .bashrc, к примеру:

{{{echo "~/path/to/clock.sh" >> ~/.bashrc}}}

== Прогресс-бар для скриптов ==
Материал из Linux Wiki
Перейти к: навигация, поиск

Пример небольшого анимированного и цифрового прогресс-бара для скриптов. К примеру, у нас есть скрипт, который в процессе выполнения выводит какие-либо строки (и мы знаем число общее строк). Тогда для большей наглядности можно использовать прогресс-бар, код которого приведен ниже.
{{{class="brush: bash"
progress() {
current="0"
while read unit
do
	let current+=1
	printf " \e[31m%s\e[32m%s\e[31m%s \e[0;36m%s%s \e[0;32m%s\e[0m\r" '[' "${pb}" ']' "$(
	echo "${1}" | awk "{print $current/$1*100}"
	)" '%' 'complete.   '
	var=$(echo -n "${pb}" | sed  -e 's@|@/@g' -e 's@\\@|@g' -e 's@-@\\@g')
	[ $var == $pb ] && pb='-' || pb=$var
done
echo
}
}}}
Данная функция увеличивает внутренний счетчик на единицу для каждой строки, переданной на stdin. Единственный параметр, который передается функции - общее число строк. В консоли при этом рисуется анимированный индикатор хода процесса и процент выполнения задачи. Проверить прогресс-бар можно, скопировав данную функцию в терминал и воспользовавшись следующим скриптом:
{{{
for i in {0..99}
do
echo
sleep .1
done | progress 100
}}}

== Получение статистики по файлам в директории ==
Материал из Linux Wiki
Перейти к: навигация, поиск

Для получения статистики по типам файлов в директории можно с помощью следующего скрипта. Помимо основной цели скрипт может "сортировать файлы по директориям, исходя из их типа. Для получения типа файла используется эвристический анализатор file:

{{{class="brush: python"
#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Script generates statistics table for specified direcories sorted by type(by
# default), overall files size or files count. This script can also sort files
# into the directories by type using hardlinks(default) or softlinks. Type
# determination is done by `file` utility.
# 
# To get help just run script with wrong parameters.
 
import os
import sys
import subprocess
import string
import getopt
import operator
 
def usage():
    print "Usage: fmetric.py [-C|-S] [-h] [-m] [-b [-s]] [-q] DIR [DIR] ...\n\
    \t-C\tSort by files count\n\
    \t-S\tSort by overall size\n\
    \t-h\tShow sizes in human-readable format\n\
    \t-m\tUse MIME types instead of file descriptions\n\
    \t-b\tCreate backup directory\n\
    \t-s\tUse softlinks (only useful with -b option)\n\
    \t-q\tUse \"quiet\" mode (do not write any error messages, skip on errors)"
 
 
def file_info(filename, flags):
    file_binary = "/usr/bin/file"
    (file_stdout, file_stderr) = subprocess.Popen( \
           [file_binary, flags, filename], \
           stdout=subprocess.PIPE,\
           stderr=subprocess.PIPE).communicate()
    return file_stdout.split(",")[0].strip('\n')
 
 
def sizeof_fmt(num, readable):
    if not readable:
        return num
 
    for x in ['bytes','KB','MB','GB','TB']:
        if num < 1024.0:
            return "%3.1f %s" % (num, x)
        num /= 1024.0
 
 
def main(argv):
    # Initializing basic variables
    backup = False
    readable = False
    use_symlinks = False
    quiet_mode = False
    info_flags = "-b"
    sort_key = 0
    info_list = []
    size_list = []
    count_list = []
 
    # Parsing command-line arguments
    try:
        opts, args = getopt.getopt(argv, "CShmbsq")
    except getopt.GetoptError:
        usage()
        sys.exit(2)
 
    for opt, arg in opts:
        if opt == "-h":
            readable = True
 
        if (opt == "-S"): 
            if (sort_key > 0):
                usage()
                sys.exit(2)
 
            sort_key = 1
 
        if (opt == "-C"):
            if (sort_key > 0):
                usage()
                sys.exit(2)
 
            sort_key = 2
 
        if (opt == "-b"):
            backup = True
 
        if (opt == "-m"):
            info_flags = "-bi"
 
        if (opt == "-s"):
            use_symlinks = True
 
        if (opt == "-q"):
            quiet_mode = True
 
    # Walk through the files and gather stats
    for dir in args:
        backup_dir = os.path.join(dir, "backup")
        if backup and os.path.exists(backup_dir):
            print "Backup directory \"%s\" exists, exiting" % backup_dir
            sys.exit(1)
 
        for root, dirs, files in os.walk(dir):
            for name in files:
                filename = os.path.join(root, name)
 
                # This might cause some errors for moved files, broken links,
                # etc. Output all errors to stderr, do not stop the script
                try:
                    size = os.path.getsize(filename)
                except OSError, (errno, strerror):
                    if not quiet_mode:
                        sys.stderr.write( "Error reading file size for %s: %s\n" % \
                                (filename, strerror) )
                    continue
 
                info = file_info(filename, info_flags)
 
                # Add stats to the comparison table
                if info in info_list:
                    index = info_list.index(info)
                    size_list[index] += size
                    count_list[index] += 1
                else:
                    info_list.append(info)
                    size_list.append(size)
                    count_list.append(1)
 
                # Create backup hardlinks/symlinks
                if backup:
                    backup_path = os.path.join(backup_dir, info)
                    link_path = os.path.join(backup_path, name)
                    if not os.path.exists(backup_path):
                        os.makedirs(backup_path)
 
                    try:
                        if  use_symlinks:
                            os.symlink(filename, link_path)
                        else:
                            os.link(filename, link_path)
 
                    except OSError, (errno, strerror):
                        if not quiet_mode:
                            sys.stderr.write( "Error creating link %s: %s\n" % \
                                    (link_path, strerror) )
 
 
    info_field_size = len(max(info_list, key=len))
 
    # Print header
    print "%s | %s | %s" % ( string.ljust("Type",info_field_size), \
            string.ljust("Size", 12), \
            "Count")
    print string.ljust("", info_field_size + 3 + 12 + 3 + 12, "=")
 
 
    # Print the result
    for info, size, count in sorted(zip(info_list, size_list, count_list), \
            key = operator.itemgetter(sort_key), reverse = (sort_key <> 0)):
        print "%s | %s | %d" % (string.ljust(info, info_field_size), \
                string.ljust(str(sizeof_fmt(size, readable)), 12), \
                count )
 
 
if __name__ == '__main__':
    if len(sys.argv) < 2:
        usage()
        sys.exit(2)
 
    main(sys.argv[1:])

Скрипт также будет полезен в связке с другим маленьким скриптом, позволяющим отсортировать найденные файлы в директории lost+found по общим директориям.

#!/bin/bash
#
# This script intends to sort files in the lost+found directory to the
# directories depending on the files' parent inodes. This can save much time
# during hand-recovering
#
# The one and only argument is `lost+found`-like directory. No checks are done.
# You are warned.
 
find $1 -maxdepth 1 -name '*_*'|while read FILE ; 
do
    FILE_NAME=`basename $FILE`
    DIR_NAME=$1/${FILE_NAME%%_*}
    mkdir -p $DIR_NAME
    mv $FILE $DIR_NAME
done
}}}

Самые свежие версии файла будут находиться на http://gist.github.com/315699
=== Ссылки ===

    * http://itblog.org.ua/post/423
    

== Common Music Collection Structure ==
Материал из Linux Wiki
Перейти к: навигация, поиск

Данная статья описывает требования к структуре файлов и метаинформации (тегов) в музыкальной коллекции.
=== Cодержание ===

    * 1 Общие правила
          o 1.1 Файловая структура
          o 1.2 Теги
    * 2 Сборники из нескольких исполнителей
    * 3 Классическая музыка
    * 4 Музыка нескольких исполнителей
    * 5 Рекомендации
    * 6 Разное
    * 7 Ссылки

=== Общие правила ===

Правила ниже описывают файловую структуру и структуру тегов для "обычной", простой структуры музыкального альбома.
Файловая структура

    * Имя исполнителя пишется в полном соответствии с оригинальным названием, например: "Øystein Sevåg" или "Піккардійська терція" в полном соответствии с тегами.
    * Имена каталогов альбомов и имен треков пишутся с заглавной буквы для каждого слова, в полном соответствии с тегами.
    * Вся дополнительная информация об альбоме находится в специальном каталоге "_album_info"
          o Для обложек дисков и буклетов выделяется подкаталог "covers"
          o Для спектрограмм - "spectrums"
          o Для текстов песен - "lyrics"
          o При необходимости добавляются нужные подкаталоги 
    * Спектрограммы имеют такое же имя файла, как и оригинальный файл, с которого они были сняты с поправкой на расширение. Формат спектрограмм - png.
          o В *nix-системах спектрограммы удобно делать утилитой sndfile-spectrogram, которая входит в пакет sndfile-tools. Рекомендуемый размер - 800х480 px, глубина построения - -100 dB. 
    * Для каждого каталога делается файл контрольных сумм, позволяющий проверить целостность файлов. Контрольные суммы делаются кроссплатформенной утилитой cfv в корне коллекции командой cfv -r -C -f checksums.sfv.
    * При необходимости проверки целостности файлов это можно сделать командой cfv -r -VV в нужном каталоге (или в корне коллекции), битые файлы будут показаны отдельно.
    * В корне альбома дополнительно находится файл front.jpg или front.png вменяемого размера, который является титульной обложкой альбома.
          o В случае наличия титульной обложки в высоком разрешении в каталоге covers, обложку для корня альбома можно создать из нее, сделав копию в разрешении 500х500 точек. 
    * Если единственной обложкой является титульная обложка диска не в высоком разрешении (размер в пределах нескольких сотен Кбайт), то подкаталог _album_info/covers можно не создавать, а ограничиться файлом front.jpg или front.png в корне альбома.
    * В случае многодискового альбома в название каталога после альбома добавляется " (Disc #)", где # - номер диска
    * В случае многодискового альбома и большого объема сканов обложек и/или буклетов общие для всех дисков сканы размещать только в подкаталогах для первого диска. 
{{{
Корень коллекции/Исполнитель	1/Год - Альбом	1/_album_info	/spectrums	/01 - Track Name.png
		|		|		|		|		|02 - Track Name.png
		|		|		|		|		|03 - Track Name.png
		|		|		|		|		|04 - Track Name.png
		|		|		|		|		|checksums.sfv
		|		|		|		|
		|		|		|		/covers		/cover1.jpg
		|		|		|		|		|cover2.png
		|		|		|		|		|checksums.sfv
		|		|		|		|
		|		|		|		/lyrics		/
		|		|		|
		|		|		|01 - Track Name.flac
		|		|		|02 - Track Name.flac
		|		|		|03 - Track Name.flac
		|		|		|04 - Track Name.flac
		|		|		|front.jpg
		|		|		|checksums.sfv
		|		|
		|		/Год - Альбом		2/
		|		|
		|		/Год - Альбом 3 (Disc 1)/
		|		|
		|		/Год - Альбом 3 (Disc 2)/
		|		|
		|		/Год - Альбом		4/
		|
		/Исполнитель	2/
		|
		/Исполнитель	3/
}}}
=== Теги ===

    * Минимально необходимые теги - исполнитель, альбом или название диска (в случае Various Artists), название трека, год выпуска диска, номер трека.
    * Номера дорожек указываются в формате xx/yy, где xx - номер дорожки, yy - количество дорожек на диске.
    * В случае многодискового альбома номер диска указывается в специально предназначенном для этого теге. Нет альбома Pink Floyd "The Wall (Disc 1)", есть двухдисковый альбом "The Wall". В случае однодискового варианта тег не указывается.
    * Имена исполнителей в тегах указываются в полном соответствии с оригинальным названием.
    * Имена альбомов, названия дисков, названия дорожек пишутся с заглавной буквы для каждого слова.
    * Среди метаинформации в тегах FLAC-дорожек должна присутствовать SEEKTABLE. 

Образец корректного блока тегов в FLAC-файле:
{{{
METADATA block #2
  type: 4 (VORBIS_COMMENT)
  is last: false
  length: 188
  vendor string: reference libFLAC 1.2.1 20070917
  comments: 8
    comment[0]: TITLE=The Door Is Open
    comment[1]: ARTIST=Øystein Sevåg
    comment[2]: ALBUM=Link
    comment[3]: DATE=1993
    comment[4]: TRACKNUMBER=01
    comment[5]: TRACKTOTAL=13
    comment[6]: GENRE=New Age
    comment[7]: CDDB=9e0c150d
}}}
Пример для двухдискового альбома:
{{{
METADATA block #2
  type: 4 (VORBIS_COMMENT)
  is last: false
  length: 209
  vendor string: reference libFLAC 1.2.1 20070917
  comments: 9
    comment[0]: TITLE=In The Flesh?
    comment[1]: ARTIST=Pink Floyd
    comment[2]: ALBUM=The Wall
    comment[3]: DISCNUMBER=1
    comment[4]: DATE=1979
    comment[5]: TRACKNUMBER=01
    comment[6]: TRACKTOTAL=13
    comment[7]: GENRE=Progressive Rock
    comment[8]: CDDB=9a09340d
}}}
=== Сборники из нескольких исполнителей ===

Сборники из нескольких исполнителей располагаются в специальном каталоге Various Artists. Так как у каждого трека может быть свой исполнитель (или несколько исполнителей), то в имя файла добавляется список исполнителей трека, перечисление идет через запятую. В остальном требования к структуре сохраняются.

{{{
Корень коллекции/Various Artists/Год - 	Название   Диска/_album_info	/spectrums	/01 - Artist - Track Name.png
				|			|		|		|02 - Artist1, Artist2 - Track Name.png
				|			|		|		|03 - Artist1, Artist2, Artist3 - Track Name.png
				|			|		|		|04 - Artist - Track Name.png
				|			|		|		|checksums.sfv
				|			|		|
				|			|		/covers		/cover1.jpg
				|			|		|		|cover2.png
				|			|		|		|checksums.sfv
				|			|		|
				|			|		/lyrics		/
				|			|
				|			|01 - Artist - Track Name.flac
				|			|02 - Artist1, Artist2 - Track Name.flac
				|			|03 - Artist1, Artist2, Artist3 - Track Name.flac
				|			|04 - Artist - Track Name.flac
				|			|front.jpg
				|			|checksums.sfv
				|
				|
				/Год - 	Название   Диска (Disc 1)/
				|
				/Год - 	Название   Диска (Disc 2)/
}}}

===  Классическая музыка ===
*ToDo:* В разработке

На данный момент определенных правил не выработано. Пока именование идет в виде "Дирижер/Год - Название диска/Номер - Название Трека", например, "Anne-Sophie Mutter/2003 - Vivaldi: The Four Seasons - Tartini: The Devil's Trill/01 - Spring, Concerto In E Major, Op. 8 No. 1. Allegro.flac"

=== Музыка нескольких исполнителей ===
*ToDo:* В разработке

На данный момент определенных правил не выработано. Исполнителей можно перечислять через запятую.
Рекомендации

    * Добавлять информацию Replay Gain в теги. Сделать это можно командой metaflac --add-replay-gain *.flac в каталоге альбома. 

=== Разное ===

    * Кодек lossless-дорожек - FLAC
    * Формат тегов в FLAC-дорожках - Vorbis Comment.
