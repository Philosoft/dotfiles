%toc

= Терминология =
| Термин | Определение                  |
|--------+------------------------------|
| клиент | окно (в привычном понимании) |

= Горячие клавиши =

=== Управление Awesome ===
Mod4 + Control + r Restart awesome.
Mod4 + Shift + q   Quit awesome.
Mod4 + r           Run prompt.
Mod4 + x           Run Lua code prompt.
Mod4 + Return      Spawn terminal emulator.
Mod4 + w           Open main menu.

=== Клиенты ===
Mod4 + Shift + r   Перерисовать окно.
Mod4 + m           Распахнуть клиент.
Mod4 + n           Свернуть клиент.
Mod4 + f           Сделать клиент полноэкранным.
Mod4 + Shift + c   Закрыть клиент.
Mod4 + t           Сделать клиент «поверх всех».

=== Навигация ===
Mod4 + j           Переключиться на следующий клиент.
Mod4 + k           Переключиться на предыдущий клиент.
Mod4 + u           Focus first urgent client.

Mod4 + Left        Посмотреть предыдущий тег.
Mod4 + Right       Посмотреть следующий тег.
Mod4 + 1-9         Переключиться на тег 1-9.

Mod4 + Control + j Focus next screen.
Mod4 + Control + k Focus previous screen

Mod4 + Escape      Focus previously selected tag set.

=== Оперирование слоями ===
Mod4 + Shift + j   Поменять местами текущий и следующий клиент.
Mod4 + Shift + k   Поменять местами текущий и предыдущий клиент.

Mod4 + o           Отправить клиент на следующий экран.

Mod4 + h           Decrease master width factor by 5%.
Mod4 + l           Increase master width factor by 5%.
Mod4 + Shift + h   Increase number of master windows by 1.
Mod4 + Shift + l   Decrease number of master windows by 1.
Mod4 + Control + h Increase number of columns for non-master windows by 1.
Mod4 + Control + l Decrease number of columns for non-master windows by 1.

Mod4 + space           Switch to next layout.
Mod4 + Shift + space   Switch to previous layout.
Mod4 + Control + space Toggle client floating status.

Mod4 + Control + Return Swap focused client with master.

Mod4 + Control + 1-9         Переключить соответствующий тег.
Mod4 + Shift + 1-9           Отметить клиент тегом.
Mod4 + Shift + Control + 1-9 Переключить тег на клиенте.
Mod4 + Shift + F1-9          Пометить отмеченные клиенты тегом.

== DEFAULT MOUSE BINDINGS ==
=== Navigation ===
Button1 on tag name           View tag.
Button4, Button5 on tag name           Switch to previous or next tag.
Button4, Button5 on root window           Switch to previous or next tag.
Button1, Button3, Button4, Button5 on layout symbol           Switch to previous or next layout.

=== Layout modification ===
Mod4 + Button1 on tag name           Tag current client with this tag only.
Mod4 + Button3 on tag name           Toggle this tag for client.
Button3 on tag name           Add this tag to current view.
Mod4 + Button1 on client window           Move window.
Mod4 + Button3 on client window           Resize window.

= Настройка =
== Собственные имена тегов ==
{{{class="brush: lua"
-- {{{ Tags
-- Define a tag table which hold all screen tags.
tags = {
  names = {"editor", "im", "www", "games", "mail", "media", "term", 8, 9},
  layout = { layouts[2], layouts[1], layouts[1], layouts[4], layouts[1],
             layouts[6], layouts[6], layouts[5], layouts[6] }
}
for s = 1, screen.count() do
    -- Each screen has its own tag table.
    tags[s] = awful.tag(tags.names, s, tags.layout)
end
-- }}}

}}}

== Автозапуск ==
Пока остановился на такой версии:
*run_once.sh* ()где-нибудь в $PATH
{{{class="brush: bash"
#!/bin/bash

# Run program unless it's already running.

if [ ! "`ps -A | grep $1`" ]; then
  $@;
fi
}}}
*rc.lua* (добавить в конец)
{{{class="brush: lua"
-- Autostart {
awful.util.spwan_with_shell("run_once.sh dropbox start")
-- }
}}}

Другой вариант:
{{{class="brush: lua"
-- This function filtred apps run by other users
function run_once(prg)
  if not prg then
    do return nil end
  end
  awful.util.spawn_with_shell("pgrep -u $USER -x " .. prg .. " ++ (" .. prg .. ")")
end
}}}

== Автомонтирование ==
{{{class="brush: bash"
sudo aptitude install halevt
}}}

== Ноификация mcabber ==
=== mcabber configuration ===
{{{class="brush: config"
set events_command = ~/.mcabber/event.sh
set events_ignore_active_window = 0
set event_log_files = 1
set event_log_dir = /tmp
}}}

As you can see we need a shellskript wrapper that pushes the bits to awesome.

*~/.mcabber/event.sh*
{{{class="brush: sh"
#!/bin/sh
echo "mcabber_event_hook('$1', '$2', '$3', '$4')" | awesome-client
}}}
Just an information about security. The shellscript above can easily be exploited locally e.g.:

{{{class="brush: sh"
./event.sh "');awful.util.spawn('xterm'); --"
}}}

However the data sent by mcabber cannot contain the tick char (') that would be needed for this exploit. The only possible data chunk may containing illegal data would be the node of the jid, but again the tick char is forbidden.

Anyway if you really dont trust incoming data you could replace the tick char everywhere with a sed command e.g.

{{{echo "mcabber_event_hook('`echo $1 | sed -e "s/'/_/g"`', ...}}}

=== awesome configuration ===

Next you have to set up your *rc.lua*

First add the profiles for status changes
{{{class="brush: lua"
naughty.config.presets.online = {
    bg = "#1f880e80",
    fg = "#ffffff",
}
naughty.config.presets.chat = naughty.config.presets.online
naughty.config.presets.away = {
    bg = "#eb4b1380",
    fg = "#ffffff",
}
naughty.config.presets.xa = {
    bg = "#65000080",
    fg = "#ffffff",
}
naughty.config.presets.dnd = {
    bg = "#65340080",
    fg = "#ffffff",
}
naughty.config.presets.invisible = {
    bg = "#ffffff80",
    fg = "#000000",
}
naughty.config.presets.offline = {
    bg = "#64636380",
    fg = "#ffffff",
}
naughty.config.presets.requested = naughty.config.presets.offline
naughty.config.presets.error = {
    bg = "#ff000080",
    fg = "#ffffff",
}
}}}

After that we add the function that handles the mcabber hook events. You have to change the variable "muc_nick" if you want awesome to hide your own MUC messages but only incoming messages.

{{{class="brush: lua"
muc_nick = "your_muc_nickname"

function mcabber_event_hook(kind, direction, jid, msg)
    if kind == "MSG" then
        if direction == "IN" or direction == "MUC" then
            local filehandle = io.open(msg)
            local txt = filehandle:read("*all")
            filehandle:close()
            awful.util.spawn("rm "..msg)
            if direction == "MUC" and txt:match("^<" .. muc_nick .. ">") then
                return
            end
            naughty.notify{
                icon = "chat_msg_recv",
                text = awful.util.escape(txt),
                title = jid
            }
        end
    elseif kind == "STATUS" then
        local mapping = {
            [ "O" ] = "online",
            [ "F" ] = "chat",
            [ "A" ] = "away",
            [ "N" ] = "xa",
            [ "D" ] = "dnd",
            [ "I" ] = "invisible",
            [ "_" ] = "offline",
            [ "?" ] = "error",
            [ "X" ] = "requested"
        }
        local status = mapping[direction]
        local iconstatus = status
        if not status then
            status = "error"
        end
        if jid:match("icq") then
            iconstatus = "icq/" .. status
        end
        naughty.notify{
            preset = naughty.config.presets[status],
            text = jid,
            icon = iconstatus
        }
    end
end
}}}
As you can see I use the gajim icons for the notifications, you may also want to use them. In the script above I also match for "icq" which is my icq transport, so the icq icons will be used but not the xmpp ones.

=== Icons ===

Add this to your rc.lua
{{{class="brush: lua"
naughty.config.icon_dirs = { os.getenv("HOME") .. ".config/awesome/naughtyicons/",  "/usr/share/pixmaps/" }
}}}
Create the directory ~/.config/awesome/naughtyicons/ extract the contents of the tarball there.
