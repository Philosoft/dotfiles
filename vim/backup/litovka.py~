# -*- coding: utf-8 -*-

import math
import pygtk
pygtk.require('2.0')
import gtk
import os

from matplotlib.pyplot import *

from matplotlib.figure import Figure
from matplotlib.backends.backend_gtkagg import FigureCanvasGTKAgg as FigureCanvas
from matplotlib.backends.backend_gtkagg import NavigationToolbar2GTKAgg as NavigationToolbar
from numpy import pi
from math import exp
from matplotlib import interactive

interactive(True)

C1 = []
C2 = []
C3 = []
C4 = []
C5 = []
T = []
time_list = []

class App(gtk.Builder):
    def __init__(self):
        super(App, self).__init__()
        self.add_from_file('litovka.ui')
        self.connect_signals(self)
        self.window1.connect('destroy', lambda x: gtk.main_quit())

        self.fig = Figure(figsize = (5,4), dpi = 100)
        self.canvas = FigureCanvas(self.fig)
        self.vbox1.pack_start(self.canvas)
        self.toolbar = NavigationToolbar(self.canvas, self.window1)
        self.vbox1.pack_start(self.toolbar, False, False)

        self.window1.show_all()
        gtk.main()

    def __getattr__(self, attr):
        obj = self.get_object(attr)
        if not obj:
            raise AttributeError('There are no such attr as `' + attr + '\'')
        setattr(self, attr, obj)
        return obj

    def click_cb(self, widget):
        self.draw([C1, C2, C3, C4, C5, time_list])

    def draw(self, list_of_lists):
        self.fig.clf()
        ax = self.fig.add_subplot(111)

        time = list_of_lists[-1]

        i = 1
        for l in list_of_lists[0:-1]:
            ax.plot(time, l, label="C%i(t)" %(i))
            i += 1
        #legend(bbox_to_anchor=(0., 1.02, 1., .102), loc=3, ncol=2, mode="expand", borderaxespad=0.)
        self.fig.canvas.draw()

# начальные значения и константы {
R = 8.31

p = 1.9

E1 = 156000.0
A1 = 10000.0
E2 = 166400.0
A2 = 20000.0
E3 = 177000.0
A3 = 50000.0
E4 = 160000.0
A4 = 500

Q1 = 361.0 * 10**3
Q2 = 950.0 * 10**3
Q4 = 152.0 * 10**4

Ct = 1200.0
Tt = 500.0
Kt = 2000.0
F = 5

V = 10

M = V * p


# объёмный расход?
vv = 0.7

# }

# перевод
#FIXME
C1v = (13.0*p)/(16.0 * 10**(-1))
C2v = (15.0*p)/(17.0 * 10**(-1))
C3v = (12.0*p)/(32.0 * 10**(-1))
C4v = 0.0
C5v = 0.0

Tv = 1200.0

def math_model(F, vv):
    # начальные точки в массивы С_i , T
    global C1, C2, C3, C4, C5, T
    C1 = [C1v]
    C2 = [C2v]
    C3 = [C3v]
    C4 = [C4v]
    C5 = [C5v]
    T  = [Tv]
    # не забыть графички

    # среднее время пребывания похоже
    # FIXME
    tau = 1.0*vv/V


    flag = True
    step = 0.01
    i = 0
    while flag:
        k1 = A1 * math.e **(-E1 / (R * T[i]))
        k2 = A2 * math.e **(-E2 / (R * T[i]))
        k3 = A3 * math.e **(-E3 / (R * T[i]))
        k4 = A4 * math.e **(-E4 / (R * T[i]))

        # концентрации
        t1 = C1[i] + step*( tau*(C1v - C1[i]) - 2*k1 * C1[i] * C2[i] * C3[i] \
                        - k2 * C1[i] * C4[i] - 2*k3 * C1[i] * C3[i])
        t2 = C2[i] + step*( tau*(C2v - C2[i]) - 2*k1 * C1[i] * C2[i] * C3[i] \
                        - 4*k4 * C2[i] * C3[i])
        t3 = C3[i] + step*( tau*(C3v - C3[i]) - 3*k1 * C1[i] * C2[i] * C3[i] \
                        - k3 * C1[i] * C3[i] - k4 * C2[i] * C3[i])
        t4 = C4[i] + step*( tau*(C4v - C4[i]) + 6*k1 * C1[i] * C2[i] * C3[i] \
                        - k2 * C1[i] * C4[i] + 6*k4 * C2[i] * C3[i])
        t5 = C5[i] + step*( tau*(C5v - C5[i]) + 2*k1 * C1[i] * C2[i] * C3[i] )
        # температура
        #FIXME множители для Q
        t6 = T[i] + step*(tau*(Tv - T[i]) + Kt * F / M / Ct * ( Tt - T[i] ) + (Q1 * k1 * C1[i] * C2[i] * C3[i]) / Ct \
                        - (Q2 * k2 * C1[i] * C4[i]) / Ct + (Q4 * k4 * C2[i] * C3[i]) / Ct)

        C1.append(t1)
        C2.append(t2)
        C3.append(t3)
        C4.append(t4)
        C5.append(t5)
        T.append(t6)

        if abs( (C5[i + 1] - C5[i]) / C5[i + 1]) < 0.00001:
            flag = False

        i += 1

    print i
    time_list.append(0)
    for t in xrange(i):
        tmp = step * (t+1)
        time_list.append(tmp)

    return C5[-1]

math_model(5, 0.7)
a = App()
