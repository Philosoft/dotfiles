#!/usr/bin/python
# -*- coding: UTF-8 -*-

import pybrain
from pybrain.tools.shortcuts import buildNetwork
from pybrain.datasets import SupervisedDataSet
from pybrain.supervised.trainers import BackpropTrainer
from pybrain.structure import SigmoidLayer

from gi.repository import Gtk

class MyWindow(Gtk.Builder):

	def __init__(self):
		super(MyWindow, self).__init__()
		self.add_from_file('pybrain_net.ui')
		self.connect_signals(self)
		self.window1.connect('delete-event', Gtk.main_quit)
		self.window1.show_all()

		self.tb = self.textview1.get_buffer()
		self.buf = ''

		self.net = buildNetwork(3, 4, 1, hiddenclass = SigmoidLayer)

	def __getattr__(self, attr):
		obj = self.get_object(attr)
		if not obj:
			raise AttributeError('There r no such attr as `' + attr + '\'')
		setattr(self, attr, obj)
		return obj

	def training(self, widget):
		self.ds = SupervisedDataSet(3, 1)
		self.ds.addSample([0.0, 0.0, 0.0], [0.0])
		self.ds.addSample([0.0, 0.0, 1.0], [0.0])
		self.ds.addSample([0.0, 1.0, 0.0], [1.0])
		self.ds.addSample([0.0, 1.0, 1.0], [0.0])
		self.ds.addSample([1.0, 0.0, 0.0], [0.0])
		self.ds.addSample([1.0, 0.0, 1.0], [1.0])
		self.ds.addSample([1.0, 1.0, 0.0], [0.0])
		self.ds.addSample([1.0, 1.0, 1.0], [1.0])

		self.buf += u"Обучаем сеть на эталонном наборе:\n"
		count = 1
		self.trainer = BackpropTrainer(self.net, self.ds, learningrate=0.1)
		err = self.trainer.train()
		while err > 0.001:
			self.buf += u"  Шаг №%i, ошибка = %2.4f\n" %(count, err)
			count += 1
			err = self.trainer.train()
			self.tb.set_text(self.buf)
		self.buf += u"Обучение закончено\n\n"
		self.tb.set_text(self.buf)
		self.scroll_to_end()

	def calc(self, widget):
		x1 = self.x1_entry.get_text()
		x2 = self.x2_entry.get_text()
		x3 = self.x3_entry.get_text()

		if x1 == "" or x2 == "" or x3 == "":
			return

		x1 = float(x1)
		x2 = float(x2)
		x3 = float(x3)

		result = self.net.activate([x1, x2, x3])

		print result
		self.buf += "f(%1.3f, %1.3f, %1.3f) = %f\n" %(x1, x2, x3, abs(result[0]))
		self.tb.set_text(self.buf)

		self.scroll_to_end()

	def scroll_to_end(self):
		insert_mark = self.tb.get_insert()
		self.tb.place_cursor(self.tb.get_end_iter())
		self.textview1.scroll_to_mark(insert_mark , 0.0, True, 0.0, 1.0)


if __name__ == '__main__':
	w = MyWindow()
	Gtk.main()
