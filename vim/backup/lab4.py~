#-*- coding: UTF-8 -*-

from visual import *
from random import uniform as rnd

#scene.range = 20
scene.width = 480
scene.height = 480
scene.y = 20

# consts {
Mb = [
		[-1.0,  3.0, -3.0, 1.0],
		[ 3.0, -6.0,  3.0, 0.0],
		[-3.0,  3.0,  0.0, 0.0],
		[ 1.0,  0.0,  0.0, 0.0]
	]
# FIXME
MbT = [range(4), range(4), range(4), range(4)]
for i in range(len(Mb)):
	for j in range(len(Mb[i])):
		MbT[i][j] = Mb[j][i]

# }

# flags {
need_points = False
# }

# vars {
pts = [ ]
for z in range(4):
	tmp = []
	for x in range(4):
		tmp.append( (x + rnd(1.0, 2.0), rnd(1.0, 8.0), z + rnd(1.0, 2.0)) )
	pts.append(tmp)
# }

# funcs {
def surf():
	surf_points = []
	Xt = [range(4), range(4), range(4), range(4)]
	Yt = [range(4), range(4), range(4), range(4)]
	Zt = [range(4), range(4), range(4), range(4)]
	X = [range(4), range(4), range(4), range(4)]
	Y = [range(4), range(4), range(4), range(4)]
	Z = [range(4), range(4), range(4), range(4)]

	Xtm = [range(4), range(4), range(4), range(4)]
	Ytm = [range(4), range(4), range(4), range(4)]
	Ztm = [range(4), range(4), range(4), range(4)]
	for i in range(4):
		for j in range(4):
			Xtm[i][j], Ytm[i][j], Ztm[i][j] = pts[i][j]

	for i in range(4):
		for j in range(4):
			Xt[i][j] = Mb[i][0]*Xtm[0][j] + Mb[i][1]*Xtm[1][j] + Mb[i][2]*Xtm[2][j] + Mb[i][3]*Xtm[3][j]
			Yt[i][j] = Mb[i][0]*Ytm[0][j] + Mb[i][1]*Ytm[1][j] + Mb[i][2]*Ytm[2][j] + Mb[i][3]*Ytm[3][j]
			Zt[i][j] = Mb[i][0]*Ztm[0][j] + Mb[i][1]*Ztm[1][j] + Mb[i][2]*Ztm[2][j] + Mb[i][3]*Ztm[3][j]
	for i in range(4):
		for j in range(4):
			X[i][j] = Xt[i][0]*MbT[0][j] + Xt[i][1]*MbT[1][j] + Xt[i][2]*MbT[2][j] + Xt[i][3]*MbT[3][j]
			Y[i][j] = Yt[i][0]*MbT[0][j] + Yt[i][1]*MbT[1][j] + Yt[i][2]*MbT[2][j] + Yt[i][3]*MbT[3][j]
			Z[i][j] = Zt[i][0]*MbT[0][j] + Zt[i][1]*MbT[1][j] + Zt[i][2]*MbT[2][j] + Zt[i][3]*MbT[3][j]

	s = 0.
	t = 0.
	while s <= 1.0:
		t = 0.
		while t <= 1.0:
			t1, t2, t3 = 0., 0., 0.

			for i in range(4):
				for j in range(4):
					t1 = t1 + X[i][j]*pow(s, (3 - i))*pow(t, (3 - j))
					t2 = t2 + Y[i][j]*pow(s, (3 - i))*pow(t, (3 - j))
					t3 = t3 + Z[i][j]*pow(s, (3 - i))*pow(t, (3 - j))
			surf_points.append((t1, t2, t3))
			t += 0.08
		s += 0.08
	return surf_points

def clear_all():
	pass

def kbd_cb(key):
	if key == 'r':
		clear_all()
	elif key == 'q':
		clear_all()
		need_points = True
# }

# система координат {
x_axis = curve(pos = [(0, 0, 0), (5, 0, 0)], radius=0.1)
y_axis = curve(pos = [(0, 0, 0), (0, 5, 0)], radius=0.1)
z_axis = curve(pos = [(0, 0, 0), (0, 0, 5)], radius=0.1)
# }

p = []
for i in range(4):
	for j in range(4):
		p.append(pts[i][j])
pt = points(pos = p, color = color.cyan)
step = 1
step_no = 0
limit = 8
while True:
	rate(14)
	if step_no == 8:
		step = -step
		step_no = 0
	else:
		step_no += 1

	x, y, z = pts[0][0]
	pts[0][0] = (x, y + step, z)
	p = []
	for i in range(4):
		for j in range(4):
			p.append(pts[i][j])
	p = surf()
	pt.visible = False
	del pt
	pt = points(pos = p, color = color.cyan)
