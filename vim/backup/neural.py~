#!/usr/bin/python3

#from gi.repository import Gtk

from random import random
from math import exp

class neuralNet():
	def __init__(self):
		self.x = []
		self.d = []
		self.y = [0, 0, 0, 0, 0, 0, 0, 0]
		self.w2 =   [0, 0, 0, 0]
		self.w1 = [ [0, 0, 0, 0],\
					[0, 0, 0, 0],\
					[0, 0, 0, 0],\
					[0, 0, 0, 0]]

		self.neural()

	def func_h(self, x, w, len):
		res = 0.
		for i in range(0, len):
			res += x[i] * w[i]

		return res

	def func_f(self, h):
		return  1. / (1. + exp(-1. * h))

	def func_e(self, d, y, len):
		res = 0.
		for i in range(0, len):
			res += (d[i] - y[i])**2

		return res / 2.

	def neural(self):
		teaching_set_x = [  [0.0, 0.0, 0.0],\
							[0.0, 0.0, 1.0],\
							[0.0, 1.0, 0.0],\
							[0.0, 1.0, 1.0],\
							[1.0, 0.0, 0.0],\
							[1.0, 0.0, 1.0],\
							[1.0, 1.0, 0.0],\
							[1.0, 1.0, 1.0] ]

		teaching_set_d = [  0.0,
							0.0,
							1.0,
							0.0,
							0.0,
							1.0,
							0.0,
							1.0]

		self.x = teaching_set_x
		self.d = teaching_set_d

		for i in range(0, 4):
			for j in range(0, 3):
				self.w1[i][j] = random()

			self.w2[i] = random()

		#buf = ""
		#for w_l in self.w1:
		#	for w in w_l:
		#		buf += "%1.4f " %(w)
		#	buf += "\n"
		#print(buf)

		#buf = ""
		#for w in self.w2:
		#	buf += "%1.4f " %(w)
		#print(buf)

	def teaching(self):
		h1 = []
		for i in range(8):
			h1.append([0., 0., 0., 0.])
		h2 = [  0.,\
				0.,\
				0.,\
				0.,\
				0.,\
				0.,\
				0.,\
				0.]
		y1 = []
		for i in range(8):
			y1.append([0., 0., 0., 0.])
		del_ = []
		for i in range(8):
			del_.append([0., 0., 0., 0.])
		delta = [   0,\
					0,\
					0,\
					0,\
					0,\
					0,\
					0,\
					0]
		E = 0.0
		count = 1
		flag = True
		while flag:
			if count == 3:
				flag = False
			print("step: ", count)
			for i in range(0, 8):
				for j in range(0, 4):
					h1[i][j] = self.func_h(self.x[i], self.w1[j], 3)
					y1[i][j] = self.func_f(h1[i][j])

				h2[i] = self.func_h(h1[i], self.w2, 4)
				self.y[i] = self.func_f(h2[i])

				print("f[", i, "] =", self.y[i], "  |  h2[", i, "] =", h2[i], "  |  y =", self.y[i])

			E = self.func_e(self.d, self.y, 8)

			#for i in range(0, 8):
			#	delta[i] = (self.d[i] - self.y[i])*(self.func_f(h2[i] + 0.01) - self.y[i])/0.01

			#for i in range(0, 4): # по нейронам
			#	for j in range(0, 8): # по наборам
			#		self.w2[i] += 0.4 * delta[j] * h1[j][i]

			#for i in range(0, 4):
			#	for j in range(0, 8):
			#		del_[j][i] = (self.func_f(h1[j][i] + 0.01) - y1[j][i])*delta[j]*self.w2[i]/0.01

			#for i in range(0, 4):
			#	for j in range(0, 4):
			#		for k in range(0, 8):
			#			self.w1[i][j]+= 0.4*del_[k][i]*self.x[k][j]
			count += 1
			#print("e =", E)
			#if E <= 0.005:
			#	flag = False

	def calculate(self, x1, x2, x3):
		h1 = [0., 0., 0., 0.]
		y1 = [0., 0., 0., 0.]
		x_now = [x1, x2, x3, 1.0]
		for i in range(0, 3):
			h1[i] = self.func_h(x_now, self.w1[i], 3)
			y1[i] = self.func_f(h1[i])

		h2 = self.func_h(h1, self.w2, 3)
		y_now = self.func_f(h2)
		print(y_now)

n = neuralNet()
n.teaching()
#n.calculate(1., 1., 1.)
