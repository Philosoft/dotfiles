# ограничения {
def f1(x1, x2):
    return (x1 - Fb)

def f2(x1, x2):
    return (Fe - x1)

def f3(x1, x2):
    return (x2 - vb)

def f4(x1, x2):
    return (ve - x2)

def fi(x1, x2):
    return (min(0, f1(x1, x2)) + min(0, f2(x1, x2)))


def opt_func(k, x1, x2, func = math_model):
    # was +k
    return func(x1, x2) - k * (min(0, f1(x1, x2))**2 + min(0, f2(x1, x2))**2 + min(0, f3(x1, x2))**2 + min(0, f4(x1, x2))**2)
# }

def Method(x10, x20, K, e1, R):
    deltax = 0.0001
    h = 0.1
    steps = 1
    overallbuf = ''
    steper  = 0.1

    overallbuf += "Перед началом метода:\n"
    overallbuf += "x10 = " + str(x10) + "  x20 = " + str(x20) + '\n'
    overallbuf += "fi(x10, x20) = " + str(fi(x10, x20)) + "  R(1, x10, x20) = " + str(R(1, x10, x20)) + '\n'
    overallbuf += "f1(x10, x20) = " + str(f1(x10, x20)) + "\n"
    overallbuf += "f2(x10, x20) = " + str(f2(x10, x20)) + "\n"
    overallbuf += "==========\n"

    flag = True
    while flag:
        x1t = x10 #запоминаем текущую точку, после отработки метода Пауэлла она станет предыдущей
        x2t = x20
        dx1 = 1
        dx2 = 1
        while dx1 <> 0 or dx2 <> 0: #метод Пауэлла
            print dx1, dx2
            x1 = x10
            x2 = x20

            fx1 = R(K, x1, x2)
            fx2 = R(K, x1+steper, x2)
            if fx1 < fx2:
                h = steper
            else:
                h = -steper
                fx2 = R(K, x1-steper, x2)

            x1 = x1 + h
            print 'stage 1...',
            while fx1 < fx2:
                print 'x1 = %2.4f x2 = %2.4f fx1 = %2.4f fx2 = %2.4f' %(x1, x2, fx1, fx2)
                fx1 = fx2
                x1 = x1+h
                fx2 = R(K, x1, x2)
            x1 = x1 - h

            fx1 = R(K, x1, x2)
            fx2 = R(K, x1, x2+steper)

            if fx1 < fx2:
                h = steper
            else:
                h = -steper
                fx2 = R(K, x1, x2-steper)

            print 'DONE'
            print 'stage 2...',
            x2 = x2 + h
            while fx1 < fx2:
                fx1 = fx2
                x2 = x2 + h
                fx2 = R(K, x1, x2)
            x2 = x2 - h

            dx1 = x1 - x10
            dx2 = x2 - x20
            fx2 = R(K, x1+dx1, x2+dx2)

            x1 = x1 + dx1
            x2 = x2 + dx2

            print 'DONE'
            print 'stage 3...',
            while fx1 < fx2:
                fx1 = fx2
                x1 = x1 + dx1
                x2 = x2 + dx2
                fx2 = R(K, x1, x2)

            print 'DONE'
            x10 = x1 - dx1
            x20 = x2 - dx2
        #пауэлл кончился
        overallbuf += "# " + str(steps) + ". При K = " + str(K) + " минимум функции равен:\n"
        overallbuf += "x1 = " + str(x10) + "  x2 = " + str(x20) + "  R(k, x10, x20) = " + str(fx2) + '\n'
        overallbuf += "fi(x10, x20) = " + str(fi(x10, x20)) + '\n'
        overallbuf += "f1(x10, x20) = " + str(f1(x10, x20)) + "\n"
        overallbuf += "f2(x10, x20) = " + str(f2(x10, x20)) + "\n"
        overallbuf += "==========\n"
        K = K*10.0 #увеличиваем к
        delta = abs(x1t - x10) + abs(x2t - x20) #точность
        steps += 1
        print '='*20
        print 'step:', steps
        print 'F =', x10, 'vv =', x20
        print 'd = %f, e = %f'
        print x10, x20
        if delta <= e1:
            flag = False
    overallbuf += "fi(x1, x2) = " + str(fi(x10, x20)) + "  R(k, x1, x2) = " + str(R(K/10, x10, x20)) + '\n'
    print overallbuf
