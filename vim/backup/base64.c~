#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <error.h>

#define MAX_LEN 76
#define MIN_LEN 4 

static const char cb64[]="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
static const char cb64_safe[]="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";

//Переводим 3 поступивших байта в 4 символа выходного алфавита
void encodeblock(unsigned char in[3], unsigned char out[4], unsigned int len)
{
  out[0] = cb64[ in[0] >> 2 ];
  out[1] = cb64[ ((in[0] & 0x03) << 4) | (in[1] >> 4) ];
  if(len > 1)
    out[2] = cb64[ ((in[1] & 0x0f) << 2) | (in[2] >> 6) ];
  else
    out[2] = '=';

  if(len > 2)
    out[3] = cb64[ (in[2] & 0x3f) ];
  else
    out[3] = '=';
}

//Собственно кодирование
void encode(FILE* inf, FILE* outf, unsigned int linesize)
{
  unsigned char in[3], out[4];
  unsigned int i, len, blocks;

  while(!feof(inf))
  {
    len = 0;
    for(i = 0; i < 3; i++)
    {
      in[i] = (unsigned char)fgetc(inf);
      if(!feof(inf))
        len++;
      else
        in[i] = 0;
    }
    if(len)
    {
      encodeblock(in, out, len);
      for(i = 0; i < 4; i++)
        putc(out[i], outf);

      blocks++;
    }
       
/*    if(blocks >= (linesize / 4) || feof(inf))
    {
      if(blocks)
      {
        putc('\r', outf);
        putc('\n', outf);
      }
      blocks = 0; //?
    }*/
  }
}

void search_char(unsigned char *c)
{
  unsigned char tmp = *c;
  unsigned char i;

  for(i = 0; i < 64; i++)
    if(tmp == cb64[i])
    {
      *c = (unsigned char)i;
      break;
    }
}

//Переводим 4 постыпивших символа выходного (base64) алфавита в первоначальное представление
void decodeblock(unsigned char in[4], unsigned char out[3])
{
  out[0] = (unsigned char)(in[0] << 2) | (in[1] >> 4);
  out[1] = (unsigned char)(in[1] << 4) | (in[2] >> 2);
  out[2] = (unsigned char)(in[2] << 6) | in[3];
}

void decode(FILE *inf, FILE *outf)
{
  unsigned char in[4], out[3], c;
  unsigned int i, len;

  while(!feof(inf))
  {
    for(len = 0, i = 0; i < 4 && !feof(inf); i++)
    {
      c = (unsigned char)getc(inf);
    //  printf("we get %c (0x%x)\n", c, c);
      
      if(c == '=')
      {
        in[i] = 0;
      }
      else
      {
        search_char(&c);
        if(!feof(inf))
        {
            len++;
            in[i] = c;
        }
        else
          in[i] = 0;
      }
    }

    if(len)
    {
      decodeblock(in, out);
//      printf("After decoding: ");
      for(i = 0; i < len - 1; i++)
      {
        fputc(out[i], outf);
  //      printf("0x%x ", out[i]);
      }
  //    printf("\n");
    }
  }
}

struct opts
{
  char *inf;
  char *outf;
  unsigned int linesize;
};

int
main(int argc, char** argv)
{
  int index;
  int c;
  opterr = 0;
  struct opts o;
  int dec_flag = 0, enc_flag = 0;

  o.inf = "stdin"; o.outf = "stdout";
  
  if(argc > 1)
  {

    while((c = getopt(argc, argv, "i:o:l:hed")) != -1)
      switch(c)
      {
        case 'i':
          o.inf = optarg;
          break;

        case 'o':
          o.outf = optarg;
          break;

        case 'l':
          if(atoi(optarg) < 4)
          {
            fprintf(stderr, "WARING: linesize less than min val. Set it to 4 (min val)\n");
            o.linesize = 4;
          }
          else
          {
            o.linesize = atoi(optarg);
          }
          break;

        case 'h':
          fprintf(stderr, "USAGE: %s [options]\n", argv[0]);
          fprintf(stderr, "Options:\n");
          fprintf(stderr, "-i specify input file\n");
          fprintf(stderr, "-o specify output file\n");
          fprintf(stderr, "-h show this help\n");
          return ;
          break;

        case 'e':
          if(dec_flag)
            fprintf(stderr, "-d option is already set\n");
          else
            enc_flag = 1;
          
          break;

        case 'd':
          if(enc_flag)
            fprintf(stderr, "-e option is already set\n");
          else
            dec_flag = 1;
          break;

        case '?':
          if(optopt == 'i' || optopt == 'o' || optopt == 'l')
            fprintf(stderr, "Option -%c requires an argument.\n", (char)optopt);

          else if (isprint(optopt))
            fprintf(stderr, "Unknown option -%c\n", (char)optopt);

          else
            fprintf(stderr, "Unknown option character %c\n", optopt);

          exit(1);

        default:
          return ;
      }
    for(index = optind; index < argc; index++)
      fprintf(stderr, "Non-option argument %c\n", argv[index]);
  }

  FILE *inf, *outf;
  inf = fopen(o.inf, "rb");
  if(!inf)
  {
    perror(o.inf);
    exit(1);
  }

  outf = fopen(o.outf, "wb");
  if(!outf)
  {
    perror(o.outf);
    exit(1);
  }

  if(enc_flag)
  {
    encode(inf, outf, o.linesize);
  }
  else if(dec_flag)
  {
    decode(inf, outf);
  }
  else
  {
    fprintf(stderr, "Не задано действие. Используйте опции -e или -d\n");
    exit(2);
  }

  fclose(inf);
  fclose(outf);

  exit(0);                                    
}
