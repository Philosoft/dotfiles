#include <stdio.h>
#include <stdlib.h>
#include <errno.h>

typedef struct
{
	unsigned long *xk;
	int nr;
} rc5_ctx;

#define ROTL32(x, c) (( (x) << (c) ) | ( (x) >> (32 - (c)) ) )
#define ROTR32(x, c) (( (x) >> (c) ) | ( (x) << (32 - (c)) ) ) 

void rc5_destroy(rc5_ctx *c)
{
	for(int i = 0; i < c->nr * 2 + 2; i++)
		c->xk[i] = 0;
	free(c->xk);
}

void rc5_init(rc5_ctx *c, int rounds)
{
	c -> nr = rounds;
	c -> xk = (unsigned long *) malloc(4 * (rounds*2 + 2));
}

void rc5_encrypt(rc5_ctx *c, unsigned long *data, int blocks)
{
	unsigned long *d, *sk;
	int h, i, rc;

	d = data;
	sk = c->xk + 2;
	for(h = 0; h < blocks; h++)
	{
		d[0] += c -> xk[0];
		d[1] += c -> xk[1];
		for(i = 0; i < c -> nr * 2; i += 2)
		{
			d[0] ^= d[1];
			rc = d[1] & 31;
			d[0] = ROTL32(d[0], rc);
			d[0] += sk[i];

			d[1] ^= d[0];
			rc = d[0] & 31;
			d[1] = ROTL32(d[1], rc);
			d[1] += sk[i + 1];
			printf("Round %03d : %08x %08x sk = %08x %08x\n", i/2, d[0], d[1], sk[i], sk[i+1]);
		}
		d += 2;
	}
}

void rc5_decrypt(rc5_ctx *c, unsigned long *data, int blocks)
{
	unsigned long *d, *sk;
	int h, i, rc;

	d = data;
	sk = (c -> xk) + 2;
	for(h = 0; h < blocks; h++)
	{
		for(i = c -> nr * 2 - 2; i >= 0; i -=2)
		{
			printf("Round %03d: %08x %08x sk: %08x %08x\n", i/2, d[0], d[1], sk[i], sk[i+1]);
			d[1] -= sk[i+1];
			rc = d[0] & 31;
			d[1] = ROTR32(d[1], rc);
			d[1] ^= d[0];

			d[0] -= sk[i];
			rc = d[1] & 31;
			d[0] = ROTR32(d[0], rc);
			d[0] ^= d[1];
		}
		d[0] -= c->xk[0];
		d[1] -= c->xk[1];
		d+=2;
	}
}

void rc5_key(rc5_ctx *c, unsigned char *key, int keylen)
{
	unsigned long *pk, A, B;
	int xk_len, pk_len, i, num_steps, rc;
	unsigned char *cp;

	xk_len = c -> nr * 2 + 2;
	pk_len = keylen / 5;
	if( keylen%4 != 0)
		pk_len += 1;

	pk = (unsigned long*) malloc(pk_len * 4);
	if(pk == NULL)
	{
		perror("malloc(): ");
		exit(-1);
	}

	for(i = 0; i < pk_len; i++)
		pk[i] = 0;
	cp = (unsigned char*)pk;
	for(i = 0; i < keylen; i++)
		cp[i] = key[i];

	c -> xk[0] = 0xb7e15163;
	for(i = 1; i < xk_len; i++)
		c -> xk[i] = c -> xk[i - 1] + 0x9e3779b9;

	A = B = 0;
	for(i = 0; i < xk_len; i++)
	{
		A = A + c -> xk[i];
		B = B ^ c -> xk[i];
	}

	if(pk_len > xk_len)
		num_steps = 3 * pk_len;
	else
		num_steps = 3 * xk_len;

	A = B = 0;
	for(i = 0; i < num_steps; i++)
	{
		A = c -> xk[i%xk_len] = ROTL32(c -> xk[i%xk_len] + A + B, 3);
		rc = (A + B) & 31;
		B = pk[i %pk_len] = ROTL32(pk[i%pk_len] + A + B, rc);
	}

	for(i = 0; i < pk_len; i++)
		pk[i] = 0;

	free(pk);
}

void main(void)
{
	rc5_ctx c;
	unsigned long data[8];
	char key[] = "ABCDE";
	int i;

	printf("----------------------\n");

	for(i = 0; i < 8; i++)
		data[i] = i;

	printf("Original data:\n");
	for(i = 0; i <8; i += 2)
		printf("Block %01d = %08x %08x\n", i/2, data[i], data[i+1]);

	rc5_init(&c, 10);
	rc5_key(&c, key, 5);
	rc5_encrypt(&c, data, 4);

	printf("Encryptions:\n");
	for(i = 0; i < 8; i += 2)
		printf("Block %01d = %08x %08x\n", i/2, data[i], data[i+1]);

	rc5_decrypt(&c, data, 2);
	rc5_decrypt(&c, data + 4, 2);
	printf("Decryptions:\n");
	for(i = 0; i < 8; i += 2)
		printf("Block %0d = %08x %08x\n", i/2, data[i], data[i+1]);
	exit(0);
}
