#!/usr/bin/python3

#from gi.repository import Gtk

from random import random
from math import exp

class neuralNet():
	def __init__(self):
		self.x = []
		self.d = []
		self.y = [0, 0, 0, 0, 0, 0, 0, 0]
		self.w2 =   [0, 0, 0]
		self.w1 = [ [0, 0, 0],\
					[0, 0, 0],\
					[0, 0, 0],\
					[0, 0, 0]]

		self.neural()

	def func_h(self, x, w, len):
		res = 0.
		for i in range(0, len):
			res += x[i] * w[i]

		return res

	def func_f(self, h):
		return  1. / (1 + exp(-1. * h))

	def func_e(self, d, y, len):
		res = 0.
		for i in range(0, len):
			res += (d[i] - y[i])**2

		return res / 2.

	def neural(self):
		tmpx = [[0.0, 0.0, 0.0],\
				[0.0, 0.0, 1.0],\
				[0.0, 1.0, 0.0],\
				[0.0, 1.0, 1.0],\
				[1.0, 0.0, 0.0],\
				[1.0, 0.0, 1.0],\
				[1.0, 1.0, 0.0],\
				[1.0, 1.0, 1.0] ]

		tmpd = [0.0,
				0.0,
				1.0,
				0.0,
				0.0,
				1.0,
				0.0,
				1.0]

		self.x = tmpx
		self.d = tmpd

		for i in range(0, 4):
			for j in range(0, 3):
				self.w1[i][j] = random()

			if i < 3:
				self.w2[i] = random()

	def teaching(self):
		h1 = []
		for i in range(8):
			h1.append([0., 0., 0., 0.])
		h2 = [0., 0., 0., 0., 0., 0., 0., 0.]
		y1 = []
		for i in range(8):
			y1.append([0., 0., 0., 0.])
		del_ = []
		for i in range(8):
			del_.append([0., 0., 0., 0.])
		delta = [0, 0, 0, 0, 0, 0, 0, 0]
		E = 0.0
		count = 1
		flag = True
		while flag:
			print("step: ", count)
			for i in range(0, 8):
				for j in range(0, 4):
					h1[i][j] = self.func_h(self.x[i], self.w1[j], 3)
					y1[i][j] = self.func_f(h1[i][j])

				h2[i] = self.func_h(h1[i], self.w2, 3)
				self.y[i] = self.func_f(h2[i])

				print("f[", i, "] =", self.y[i])

			E = self.func_e(self.d, self.y, 8)

			for i in range(0, 8):
				delta[i] = (self.d[i] - self.y[i])*(self.func_f(h2[i] + 0.01) - self.y[i])/0.01

			for ind in range(0, 3): # по входам
				for i in range(0, 4): # по нейронам
					for j in range(0, 8): # по наборам
						self.w2[ind] += 0.2 * delta[j] * h1[j][i]

			for ind in range(0, 3):
				for i in range(0, 4):
					for j in range(0, 8):
						del_[j][i] = (self.func_f(h1[j][i] + 0.01) - y1[j][i])*delta[j]*self.w2[ind]/0.01

			for i in range(0, 4):
				for j in range(0, 3):
					for k in range(0, 8):
						self.w1[i][j]+= 0.2*del_[k][i]*self.x[k][j]
			count += 1
			print("e =", E)
			if E <= 0.005:
				flag = False

	def calculate(self, x1, x2, x3):
		h1 = [0., 0., 0., 0.]
		y1 = [0., 0., 0., 0.]
		x_now = [x1, x2, x3, 1.0]
		for i in range(0, 3):
			h1[i] = self.func_h(x_now, self.w1[i], 3)
			y1[i] = self.func_f(h1[i])

		h2 = self.func_h(h1, self.w2, 3)
		y_now = self.func_f(h2)
		print(y_now)

n = neuralNet()
n.teaching()
n.calculate(1., 1., 1.)
