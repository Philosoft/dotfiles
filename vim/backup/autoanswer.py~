# -*- coding: utf-8 -*-

'''Принимает сообщения для указанных пользователей
и отправляет их при появлении пользователя в сети'''

#TODO: Придумать систему, которая будет отслеживать появление
# юзера в сети и отправлять уведомление об оставленных сообщениях
#TODO: Доработать систему на приём сообщений, отправленных пользователям,
# которых нет в сети, а не только через команду или алиас

import re,os
import time
import common

dbfile = 'plugins/autoanswer.txt'
try:
	storeOfflineMessages = common.load_settings().storeOfflineMessages
except:
	storeOfflineMessages = True

#{{{Атрибуты плагина
attrs = {
		"enabled":True, #Плагин активен
		"shared":False, #Это общий плагин. Через него будут проходить все сообщения
		"public":True, #Плагин не публиный и не виден никому, кроме админов (но может работать, если shared)
		"aliases":(u"msg",), #Список алиасов этого плагина
		"presence":True,
		}
#}}}

def init(bot=None):#{{{Инициализация плагина
	#Тут будут выполняться те действия,
	#которые нужны при загрузке плагина

	#Возвращаем параметры плагина
	return attrs
#}}}

def run(mess, bot): #{{{Обработчик сообщений
	'''Записывает сообщения для указанного пользователя или
	возвращает оставленные сообщения по запросу'''

	if not mess.getType() == 'groupchat':
		return

	#TODO: Получить getFrom() в отдельную переменную и дальше работать уже с ней
	
	try:
		message = unicode(mess.getBody()).split('msg ')[1].lstrip()#Отрезаем сообщение от команды
	except:
		return "Что для кого я должна записать?"
	if message == "+": # Если сообщение "+", 
		# то нам надо только получить сообщения, оставленные для этого пользователя
		return returnMessages(mess, bot)
	elif message == '' or message == ' ' or message == None: # Если сообщение пустое - посылаем нафиг
		return "Кому и что я должен передать?"
	
	messto = unicode(mess.getFrom()).split('/')[0] # Запоминаем комнату
	messto += "/"
	messto_ = message.split(' ')[0] # Запоминаем кому адресовано
	messto += messto_ # Добавляем адресата к имени комнаты (через слэш, который добавлен выше)
	mfrom = unicode(mess.getFrom()).split('/')[1].encode('utf-8') # Запоминаем ник отправителя
	message = message.split(messto_)[1] # Отрезаем текст сообщения от ника получателя. Это и будет самим сообщением
	
	if message == '' or message == ' ': # Если сообщение пустое - посылаем нафиг
		return "Пустой текст записывать не буду!"

	ts = time.strftime("%Y-%m-%d %H:%M:%S").encode('utf-8') # Запомнили текущее время
	# Побираем базу из файла
	global dbfile
	try:
		db = eval(file(dbfile).read())
	except SyntaxError:
		db={}
	except:
		return "Ой, простите, не могу записать - записывалка сломалась!"
	message = "%s от %s: %s"%(ts,mfrom, message.encode('utf-8')) # Сформировали сообщение 
	if not db.has_key(messto): # Если сообщений для этого ника ещё нет и не было
		db[messto] = [] # То создаём список для него
	db[messto].append(message) # Добавляем сообщение в список
	# Записываем обновлённый словарь назад в файл
	file(dbfile, 'w').write(unicode(db))
	# Ну и отчитаться не забываем
	return "%s, записала!"%(mfrom)
#}}}

def runP(mess,bot): #{{{Обработчик пресенсов
	'''Мониторит вход пользователей. Каждого вошедшего проверяем по базе
	оставленных сообщений, и если есть для него сообщения — уведомляет
	его об оставленных сообщениях'''
	_from = unicode(mess.getFrom()).split('/')[1]
   pass
	print "Get precense from" , _from
	#}}}

def returnMessages(mess, bot): #{{{Выдача сообщений по запросу
	'''Выдаёт оставленные сообщения для пользователя по запросу'''
	global dbfile

	addr = unicode(mess.getFrom())# Запомнили адресата
	message = ""

	try: # Пытаемся инициализировать (получить) базу сообщений
		db = eval(file(dbfile).read())
	except SyntaxError:
		db = {}
	except:
		return "Ой, простите, записная книжка потерялась..."
	
	# Если для этого адресата есть сообщения и их больше 0
	if db.has_key(addr) and len(db[addr]) > 0:
		for rec in db[addr]: # Проходимся по всем сообщениям
			message += rec # Записываем в переменную, формируя вывод
			message += "\n"
			db[addr].remove(rec) # И попутно удаляем их из базы
	else: # А если ничего нет, то так и говорим
		message = "А нету для вас сообщений!"
	
	file(dbfile, 'w').write(unicode(db)) # Сохраняем обновлённую базу
	
	#Отсылаем сообщение
	return message
#}}}
