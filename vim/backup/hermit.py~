#!/usr/bin/python2
# -*- coding: utf-8 -*-

from math import factorial as fact
import sys
import pygame as pg

#TODO:
#	update_vektors
#	коэффициент по +/-

pg.init()

size = width, height = 640, 480
black = 0, 0, 0

screen = pg.display.set_mode(size)

### Global {{{
points_list = []
mode_list = [u'1: Эрмит [2 точки]', u'2: Эрмит [n точек]']
current_mode = 0
glob_vh = {}
coef = 1.0
screen_changed = False
### }}}


def hermit(points):
    screen_changed = True
    pts = []
    step = 0.01
    t = 0
    p1_x, p1_y = points[0]
    p4_x, p4_y = points[1]
    r1_x, r1_y = points[2]
    r4_x, r4_y = points[3]

    r1_x = r1_x - points[0][0]
    r1_y = r1_y - points[0][1]
    r4_x = r4_x - points[1][0]
    r4_y = r4_y - points[1][1]
    while t <= 1:
        x = p1_x * (2*t**3 - 3*t**2 + 1) + p4_x * (-2 * t**3 + 3*t**2) + coef * (r1_x*(t**3 - 2*t**2 + t) + r4_x * (t**3 - t**2))
        y = p1_y * (2*t**3 - 3*t**2 + 1) + p4_y * (-2 * t**3 + 3*t**2) + coef * (r1_y*(t**3 - 2*t**2 + t) + r4_y * (t**3 - t**2))
        pts.append( (x, y) )
        t += step

    return pts

def change_title(title):
    ''' remove all but text '''
    screen_changed = False
    screen.fill((0, 0, 0))
    if len(points_list):
        redraw_points()
        if len(points_list) > 1:
            redraw_curve()
    font = pg.font.Font(None, 17)
    text = font.render(title, True, (255, 255, 255))
    textRect = text.get_rect()
    textRect.centerx = screen.get_rect().centerx
    textRect.centery = 17
    screen.blit(text, textRect)

def next_mode():
    global current_mode
    if current_mode < len(mode_list) - 1:
        current_mode += 1
    else:
        current_mode = 0

    screen_changed = True
    change_title(mode_list[current_mode])

def prev_mode():
    global current_mode
    if current_mode > 0:
        current_mode -= 1
    elif current_mode == 0:
        current_mode = len(mode_list) - 1
    screen_changed = True
    change_title(mode_list[current_mode])

def redraw_all():
    if not screen_changed:
        return
    if len(points_list) >= 2:
        screen.fill((0,0,0))
        change_title(mode_list[current_mode])
        if len(points_list):
            redraw_points()
            draw_vektors(glob_vh)
            if len(points_list) > 1:
                redraw_curve()

def do_job(mode):
    if mode == 0:
        pts = [points_list[0], points_list[1]]
        r1 = glob_vh[str(points_list[0])]['b']
        r2 = glob_vh[str(points_list[1])]['e']
        pts.append(r1)
        pts.append(r2)
        pg.draw.lines(screen, (50, 250, 50), False, hermit(pts), 1)
    if mode == 1:
        i = 0
        while i < len(points_list) - 1:
            pts = [points_list[i], points_list[i+1]]
            r1 = glob_vh[str(points_list[i])]['b']
            r2 = glob_vh[str(points_list[i+1])]['e']
            pts.append(r1)
            pts.append(r2)
            pg.draw.lines(screen, (50, 250, 50), False, hermit(pts), 1)
            i += 1

def redraw_points():
    for i in points_list:
        pg.draw.circle(screen, (255, 50, 50), i, 5, 0)

def redraw_curve():
    do_job(current_mode)

def update_vektors():
    screen_changed = True
    if len(glob_vh) == 0:
        if len( points_list ) == 2:
            make_vektors(points_list)
    else:
        last_p = points_list[-1]
        glob_vh[str(last_p)] = {'e': (last_p[0], last_p[1] - 30)}

        glob_vh[str(points_list[-2])]['b'] = (points_list[-2][0], points_list[-2][1] - 60)

def make_vektors(pts_l):
    for i in pts_l[1 : len(pts_l) - 1]:
        x_p, y_p = i
        x = x_p
        y = y_p - 30
        glob_vh[str(i)] = {'b': (x, y), 'e': (x, y - 60)}
    x_p, y_p = pts_l[0]
    x = x_p
    y = y_p - 30
    glob_vh[str(pts_l[0])] = {'b': (x, y)}
    x_p, y_p = pts_l[-1]
    x = x_p
    y = y_p - 60
    glob_vh[str(pts_l[-1])] = {'e': (x, y)}
    #draw_vektors(glob_vh)

def vektor_to_list(v):
    return v.values()

def draw_vektors(g_vh):
    for key in g_vh:
        from_str = filter(lambda c: c not in '(,)', key)
        from_p = (int(from_str.split(' ')[0]), int(from_str.split(' ')[1]))
        for key_variant in g_vh[key]:
            to_p = g_vh[key][key_variant]
            if key_variant == 'e':
                pg.draw.line(screen, (150, 150, 150), from_p, to_p, 1)
                pg.draw.circle(screen, (50, 50, 250), to_p, 5)
            else:
                pg.draw.line(screen, (250, 250, 250), from_p, to_p, 1)
                pg.draw.circle(screen, (250, 50, 250), to_p, 5)


def rotate_vektor(f_key, s_key, old_coords_fp):
    if s_key == 'b':
        ss_key = 'e'
    else:
        ss_key = 'b'

    new_coords_fp = glob_vh[f_key][s_key]
    old_coords_sp = glob_vh[f_key][ss_key]

    dx = old_coords_fp[0] - new_coords_fp[0]
    dy = old_coords_fp[1] - new_coords_fp[1]

    if old_coords_fp[0] > new_coords_fp[0]:
        new_x = old_coords_sp[0] + dx
    else:
        new_x = old_coords_sp[0] - dx

    if old_coords_fp[1] > new_coords_fp[1]:
        new_y = old_coords_sp[1] - dy
    else:
        new_y = old_coords_sp[1] + dy

    new_pos = (new_x, new_y)

    glob_vh[f_key][ss_key] = new_pos


### global flags {
moving = False
moving_head = False
old_val = ''
cur_parent_point = ''
### }
change_title(u'1: Эрмит [2 точки]')
while 1:
    for event in pg.event.get():
        if event.type == pg.QUIT: sys.exit()

        elif event.type == pg.KEYDOWN:
            # стираем всё
            if event.key == pg.K_r:
                points_list = []
                glob_vh = {}
                change_title(mode_list[current_mode])
            if event.key == pg.K_SPACE:
                points_list = []
                glob_vh = {}
                next_mode()
            if event.key == pg.K_LCTRL:
                points_list = []
                glob_vh = {}
                prev_mode()
            if event.key == pg.K_UP:
                coef += 1.0
                if len(points_list) >= 2:
                    redraw_all()
            if event.key == pg.K_DOWN:
                if coef > 1:
                    coef -= 1.0
                elif coef > 0.1 and coef <= 1:
                    coef -= 0.1
                if len(points_list) >= 2:
                    redraw_all()

        elif event.type == pg.MOUSEBUTTONDOWN:
            if event.button == 1:
                x, y = event.pos
                if not moving:
                    # проверим, не тыкнули ли мы в точку
                    for i in points_list:
                        if (x > i[0] - 5 and x < i[0] + 5) and (y > i[1] - 5 and y < i[1] + 5):
                            moving = True
                            old_val = i
                    # проверем, не тыкнули ли мы в «голову» вектора
                    if not moving:
                        for parent_point in glob_vh:
                            for key in glob_vh[parent_point]:
                                i = glob_vh[parent_point][key]
                                if (x > i[0] - 5 and x < i[0] + 5) and (y > i[1] - 5 and y < i[1] + 5):
                                    moving = True
                                    moving_head = True
                                    old_val = key
                                    cur_parent_point = parent_point

                    if not moving:
                        if current_mode == 0:
                            if len(points_list) < 2:
                                points_list.append( (x, y) )
                                pg.draw.circle(screen, (255, 50, 50), (x, y), 5, 0)
                                if len(points_list) == 2:
                                    make_vektors(points_list)
                        elif current_mode == 1:
                            points_list.append( (x, y) )
                            pg.draw.circle(screen, (255, 50, 50), (x, y), 5, 0)
                            update_vektors()

                    screen_changed = True
            if event.button == 3:
                screen_changed = True
                do_job(current_mode)

        elif event.type == pg.MOUSEBUTTONUP:
            if moving:
                moving = False
                screen_changed = True
                if moving_head:
                    moving_head = False
                    old_coords = glob_vh[cur_parent_point][old_val]
                    glob_vh[cur_parent_point][old_val] = event.pos
                    #if current_mode == 1:
                    #    rotate_vektor(cur_parent_point, old_val, old_coords)


                else:
                    p_p = str(old_val)
                    vektor_bak = glob_vh[p_p]
                    del glob_vh[p_p]
                    new_p_p = str(event.pos)
                    glob_vh[new_p_p] = vektor_bak
                    old_ind = points_list.index(old_val)
                    points_list.remove(old_val)
                    points_list.insert(old_ind, event.pos)

            redraw_all()

    pg.display.flip()
