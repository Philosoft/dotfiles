#include <stdlib.h>
#include <math.h>
#include <string.h>

#include <iostream>
#include <fstream>

using namespace std;

double step = 0.01;
double accuracy  = 0.001;
double *x;
double *y;

double koshi(double a, double lambda)
{
    int i = 1;
    double h = step;
    
    y[0] = a;
    
    for(double t = step; t < 1 + step; t += step)
    {
        double *ky, *kx, kox, koy;
        
        kx = new double[4];
        ky = new double[4];
        
        ky[0] = lambda / 2;
        ky[1] = lambda / 2;
        ky[2] = lambda / 2;
        ky[3] = lambda / 2;
        koy = (1.0 / 6.0) * (ky[0] + 2*ky[1] + 2*ky[2] + ky[3]);
        y[i] = y[i-1] + h*koy;
        
        kx[0] = y[i-1];
        kx[1] = (y[i-1] + kx[0] * h/2);
        kx[2] = (y[i-1] + kx[1] * h/2);
        kx[3] = (y[i-1] + kx[2] * h);
        kox = (1.0/6.0) * (kx[0] + 2*kx[1] + 2*kx[2] + kx[3]);
        x[i] = x[i-1] + h*kox;
        i++;
    }

    return x[i-1];
}

double func(double lambda)
{
    double *alpha;
    double *beta;
    int n = (int) (1/step) + 1;
    
    alpha = new double[n];
    beta  = new double[n];
    double a, b, c, d;
    a =  1 / (step*step);
    b = -2 / (step*step);
    c =  1 / (step*step);
    
    double h = step;
    d = lambda/2;
    x[0] = 1.0;
    x[n-1] = 6.0;
    
    alpha[0] = 0.0;
    beta[0] = 0.0;
    alpha[1] = -c/b;
    beta[1] = (d - a*x[0])/b;
    
    for(int i = 2; i < n-2; i++)
    {
        alpha[i] = -c/(a*alpha[i-1] + b);
        beta[i] = (d - a*beta[i-1])/(a*alpha[i-1] + b);
    }
    x[n-2] = (d - a*x[n-1] - a*beta[n-3])/(a*alpha[n-3] +b);
    
    for(int i = n-3; i > 0; --i)
    {
        x[i] = alpha[i]*x[i+1] + beta[i];
    }
    
    double integr = 5.0;
    integr = (x[0] + x[n-1])/2;
    for(int i = 1; i < n-1; i++)
        integr = integr + x[i];
        
    integr = integr*h;

    return integr;
}

int main(int argc, char **argv)
{
    step = atof(argv[1]);
    accuracy = atof(argv[2]);

    ofstream f_plot("//tmp//f_plot", ios::out), s_plot("//tmp//s_plot", ios::out), info("//tmp//info", ios::out);

    double a0 = 1.0, a = a0;
    int raz = (int) (1/step) + 1;
    x = new double [raz];
    y = new double [raz];
    
    x[0] = 1.0;
    double lambda0 = -8.0, lambda = lambda0;
    double yn = 6.0, delta = 0.01;
    int n = 0;
    
    double integr = 0;
    double st;
    
    if(a > 2)
        st = -0.01;
    else
        st = 0.01;
    
    do
    {
        do
        {
            lambda = lambda0;
            lambda0 = lambda - ((koshi(a, lambda) - yn)/(koshi(a, lambda+delta) - koshi(a, lambda)))*delta;
        } while(fabs(lambda0 - lambda) > accuracy);
        
        koshi(a, lambda);
        integr = (x[0] + x[raz-1])/2;
        for(int d = 1; d < raz-1; d++)
            integr = integr + x[d];
        integr = integr * step;
        
        a = a + st;
    } while(fabs(integr - 3) > accuracy);


    koshi(a, lambda0);
    n = 0;
    for(double i = 0; i < 1 + step; i += step)
    {
        info<<"t = "<<i<<" ; x = "<<x[n]<<endl; 
        f_plot<<i<<" "<<x[n]<<" ";
        n++;
    }
            
    do //прогонка
    {
        lambda = lambda0;
        lambda0 = lambda - (func(lambda0) - 3)/(func(lambda0+delta) - func(lambda0))*delta;
    } while(fabs(lambda - lambda0) > accuracy);
    
    info<<"λ = "<<lambda<<endl;
    
    n = 0;
    for(double i = 0; i < 1 + step; i += step)
    {
        info<<"t = "<<i<<" ; x = "<<x[n]<<endl;
        s_plot<<i<<" "<<x[n]<<" ";
        n++;
    }

    integr = (y[0]*y[0] + y[n-1]*y[n-1])/2;
    for(int i = 1; i < n-1; i++)
        integr = integr + y[i] * y[i];;

    integr = integr*step;

    info<<"Интеграл по методу трапеций: "<<integr<<endl;
    info<<"Аналитический интеграл: 28"<<endl;

    info.close(); s_plot.close(); f_plot.close();

    exit(EXIT_SUCCESS);
}
