#-*- coding: UTF-8 -*-

from visual import *
from visual.controls import *
import subprocess

scene.range = 30
scene.width = 480
scene.height = 480
scene.y = 20

# creating controls would be here
## {
c = controls(x = 480, y = 20, width = 480, height = 480)
#b1 = button(pos = (-60, 40), height = 20, width = 50, text = u"Переместить", action = lambda: moving_call())
b2 = button(pos = (-35, 45), height = 20, width = 50, text = u"Старт", action = lambda: start_sim())
b3 = button(pos = (35, 45), height = 20, width = 50, text = u"Очистить", action = lambda: clear_all())
b4 = button(pos = (-40, 10), height = 30, width = 80, text = u"Повернуть\nшестерню", action = lambda: rotate_gear())
b5 = button(pos = (40, 10), height = 30, width = 80, text = u"Подвинуть\nшестерню", action = lambda: move_gear())
#_menu = menu(pos = (-25, 15), height = 10, width = 60, text = u"Что двигать")
#_menu.items.append( (u"Точку", lambda: ch_mov_obj('point')) )
#_menu.items.append( (u"Шестерню", lambda: ch_mov_obj('gear')) )
title = button(pos = (-5, 80), height = 30, width = 85, text = u"Расстановка объектов")

draw_line_toggle = toggle(pos = (0, -40), height = 20, text0=u"Рисовать линию связи", text1=u"Не рисовать линию связи", action = lambda: toggle_line())
## }

# globals
## flag-modes {
mode_place_obj = True
mode_place_pts = False
mode_rotate_obj = False
mode_move_obj = False
mode_move_pts = False
mode_sim_active = False
sim_started = False

some_flag = False
draw_len_line = True
## }

## vars {
obj_counter = 0
obj_list = []
pts_counter = 0
pts_list = []

pick = None
radius = 5
minimum = 10**4
## }


init_p1 = 0.0
init_p2 = 0.0
sim_counter = 0
what_to_move = 'point'
len_line = ''
center1 = ()
cetner_ax1 = ()
center2 = ()
center_ax2 = ()
# }

## {
def move_gear():
    global title
    title.text = u"Перемещение шестерней"
    global mode_place_obj, mode_move_obj
    mode_place_obj = False
    mode_move_obj = True

def rotate_gear():
    global title
    title.text = u"Поворот шестерней"
    global mode_place_obj, mode_place_pts, mode_rotate_obj, mode_move_obj, mode_sim_active, sim_started, some_flag, obj_counter, pts_counter, pts_list, obj_list
    global mode_move_pts
    mode_place_obj, mode_move_obj, mode_place_pts, mode_move_pts = False, False, False, False
    mode_rotate_obj = True
    #mode_sim_active = False
    #sim_started = False
    #some_flag = False

def toggle_line():
    global draw_len_line
    draw_len_line = not draw_len_line

    global len_line
    try:
        len_line.visible = False
        del len_line
    except Exception:
        pass

    if draw_len_line:
        for i in f1.objects:
            if i == pts_list[0].sphere:
                start_pt = f1.frame_to_world(pts_list[0].sphere.pos)
            elif i == pts_list[1].sphere:
                end_pt = f1.frame_to_world(pts_list[1].sphere.pos)
        for i in f2.objects:
            if i == pts_list[0].sphere:
                start_pt = f2.frame_to_world(pts_list[0].sphere.pos)
            elif i == pts_list[1].sphere:
                end_pt = f2.frame_to_world(pts_list[1].sphere.pos)
        len_line = curve(pos = [start_pt, end_pt], radius = 0.1, color = color.yellow)


def start_sim():
    global obj_counter, pts_counter
    if obj_counter != 2 and pts_counter != 2:
        return
    else:
        global title
        title.text = u"Симуляция"
        global mode_place_obj, mode_place_pts, mode_rotate_obj, mode_move_obj, mode_sim_active, sim_started, some_flag, pts_list, obj_list
        global mode_move_pts
        mode_place_obj, mode_move_obj, mode_place_pts, mode_move_pts = False, False, False, False
        mode_sim_active = True
        sim_started = False
        global mode_rotate_obj
        mode_rotate_obj = False


def ch_mov_obj(what):
    global what_to_move
    what_to_move = what

def moving_call():
    global mode_place_obj, mode_place_pts, mode_rotate_obj, mode_move_obj, mode_sim_active, sim_started, some_flag, obj_counter, pts_counter, pts_list, obj_list
    global mode_move_pts
    global what_to_move
    mode_place_obj = False
    mode_place_pts = False
    mode_rotate_obj = False
    tit = u"Перемещение "
    if what_to_move == 'gear':
        mode_move_obj = True
        tit += u"объекта"
    else:
        mode_move_obj = False
    if what_to_move == 'point':
        mode_move_pts = True
        tit += u"точки"
    else:
        mode_move_pts = False
    mode_sim_active = False
    sim_started = False

    some_flag = False
    global title
    title.text = tit

def clear_all():
    global mode_place_obj
    global mode_place_pts
    global mode_rotate_obj
    global mode_move_obj
    global mode_sim_active
    global sim_started
    global some_flag
    global obj_counter
    global pts_counter
    global pts_list
    global obj_list

    mode_place_obj = True
    mode_place_pts = False
    mode_rotate_obj = False
    mode_move_obj = False
    mode_sim_active = False
    sim_started = False

    some_flag = False

    obj_counter = 0
    pts_counter = 0
    o1, o2 = obj_list
    p1, p2 = pts_list
    pts_list = []
    obj_list = []
    o1.set_invisible()
    o2.set_invisible()
    p1.set_invisible()
    p2.set_invisible()
    del o1, o2, p1, p2

    global minimum, sim_counter, delta
    minimum = 10. ** 4
    sim_counter = 0.
    delta = 0.
    global len_line
    len_line.visible = False
    del len_line

    global title
    title.text = u"Расстановка объектов"
## }

class gear():
    def __init__(self, pos, end_p):
        self.shape = shapes.gear(n = 10)
        self.pos = [pos, end_p]
        self.color = color.red

        self.obj = extrusion(shape = self.shape, pos = self.pos, color = self.color)

    def set_invisible(self):
        self.obj.visible = False

class pt():
    def __init__(self, pos):
        self.pos = pos
        self.sphere = sphere(pos = self.pos, color = color.green)

    def set_frame(self, f):
        self.sphere.frame = f

    def set_color(self, c):
        self.sphere.color = c

    def set_pos(self, pos):
        self.sphere.pos = pos

    def set_invisible(self):
        self.sphere.visible = False

def _ap_eq(a, b, e = 0.01):
    if a >= b - e and a <= b + e:
        return True
    else:
        return False

def aprox_eq(a, b, e = 0.01):
    if _ap_eq(a.x, b.x, e)\
       and\
       _ap_eq(a.y, b.y, e)\
       and\
       _ap_eq(a.z, b.z, e):
        return True
    else:
        return False

f1 = frame(pos = (0, 0, 0))
f2 = frame(pos = (0, 0, 0))

# система координат {
x_axis = curve(pos = [(0, 0, 0), (9, 0, 0)], radius=0.1)
y_axis = curve(pos = [(0, 0, 0), (0, 9, 0)], radius=0.1)
z_axis = curve(pos = [(0, 0, 0), (0, 0, 9)], radius=0.1)
# }
while True:
    rate(50)
    if mode_place_obj:
        if scene.kb.keys:
            k = scene.kb.getkey()
            if k == "f1":
                subprocess.call(["firefox", "help.html"])
        if obj_counter == 2:
            mode_place_obj = False #вывод предупреждения
            mode_place_pts = True
            title.text = u"Расстановка точек"
        else:
            if scene.mouse.clicked:
                m = scene.mouse.getclick()
                obj_counter += 1
                if obj_counter == 2:
                    vec = vector(obj_list[0].obj.pos[0])
                    if aprox_eq(vec, m.pos, 5):
                        #print 'too close'
                        obj_counter -= 1
                    else:
                        x, y, z = m.pos
                        end_p = (x, y, z + 4)
                        obj = gear(m.pos, end_p)
                        obj_list.append(obj)
                else:
                    x, y, z = m.pos
                    end_p = (x + 4, y, z + 4)
                    obj = gear(m.pos, end_p)
                    obj_list.append(obj)
    elif mode_move_obj:
        if scene.kb.keys:
            k = scene.kb.getkey()
            which = 0
            delta_x, delta_y, delta_z = 0, 0, 0
            if k == "f1":
                subprocess.call(["firefox", "help.html"])
            elif k == "a":
                which = 1
                delta_x = -0.5
            elif k == "d":
                which = 1
                delta_x = 0.5
            elif k == "w":
                which = 1
                delta_y = 0.5
            elif k == "s":
                which = 1
                delta_y = -0.5
            elif k == "q":
                which = 1
                delta_z = -0.5
            elif k == "e":
                which = 1
                delta_z = 0.5
            elif k == "j":
                which = 2
                delta_x = -0.5
            elif k == "l":
                which = 2
                delta_x = 0.5
            elif k == "i":
                which = 2
                delta_y = 0.5
            elif k == "k":
                which = 2
                delta_y = -0.5
            elif k == "u":
                which = 2
                delta_z = -0.5
            elif k == "o":
                which = 2
                delta_z = 0.5

            if which == 1:
                f1.pos += (delta_x, delta_y, delta_z)
            elif which == 2:
                f2.pos += (delta_x, delta_y, delta_z)

    elif mode_place_pts:
        if scene.kb.keys:
            k = scene.kb.getkey()
            if k == "f1":
                subprocess.call(["firefox", "help.html"])
        if pts_counter == 2:
            mode_place_pts = False
            mode_sim_active = True
            title.text = u"Симуляция"
        else:
            if scene.mouse.clicked:
                m = scene.mouse.getclick()
                pts_counter += 1

                position = m.pos
                p = pt(position)
                pts_list.append(p)
    # двигаем точки {
    elif mode_move_pts:
        if scene.kb.keys:
            k = scene.kb.getkey()
            if k == "f1":
                subprocess.call(["firefox", "help.html"])
        if scene.mouse.events:
            m1 = scene.mouse.getevent()
            if m1.drag and (m1.pick == pts_list[0].sphere or m1.pick == pts_list[1].sphere):
                drag_pos = m1.pickpos
                pick = m1.pick
            elif m1.drop:
                pick = None
        if pick:
            new_pos = scene.mouse.pos
            if new_pos != drag_pos:
                distance = new_pos - drag_pos
                drag_pos = new_pos
                pick.pos += distance
    # }
    elif mode_rotate_obj:
        if scene.kb.keys:
            k = scene.kb.getkey()
            rotate = None
            origin = ()
            axis = (0, 4, 0)
            alpha = 0.0
            if k == "f1":
                subprocess.call(["firefox", "help.html"])
            elif k == "a":
                #rotate ← 1st obj
                rotate = 1
                alpha = radians(1)
                origin = center1
            elif k == "d":
                #rotate → 1st obj
                rotate = 1
                alpha = radians(-1)
                origin = center1
                x, y, z = origin
            elif k == "j":
                #rotate ← 2nd obj
                rotate = 2
                alpha = radians(1)
                origin = center2
            elif k == "l":
                #rotate → 2st obj
                rotate = 2
                alpha = radians(-1)
                origin = center2

            if rotate == 1:
                #FIXME
                f1.rotate(axis = axis, origin = origin, angle = alpha)
                center1 = f1.frame_to_world(obj_list[0].obj.pos[0])
                center_ax1 = f1.frame_to_world(obj_list[0].obj.pos[1]) - f1.frame_to_world(obj_list[0].obj.pos[0])
            elif rotate == 2:
                f2.rotate(axis = axis, origin = origin, angle = alpha)
                center2 = f2.frame_to_world( obj_list[1].obj.pos[0] )
                center_ax2 = f2.frame_to_world( obj_list[1].obj.pos[1] ) - f2.frame_to_world( obj_list[1].obj.pos[0] )
    elif mode_sim_active:
        if scene.kb.keys:
            k = scene.kb.getkey()
            if k == "f1":
                subprocess.call(["firefox", "help.html"])
        if not sim_started:
            init_p1 = pts_list[0].sphere.pos
            init_p2 = pts_list[1].sphere.pos

            delta = 0.
            minimum = 10.0 ** 4
            sim_counter = 0
            v0 = vector(1, 0, 0)
            v1 = vector(1, 0, 0)

            va = vector(init_p1)
            va_c = vector(obj_list[0].obj.pos[0])
            va = va - va_c

            vb = vector(init_p2)
            vb_c = vector(obj_list[1].obj.pos[0])
            vb = vb - vb_c


            #определим какой объект ближе
            # для первой точки {
            vt1 = vector(pts_list[0].sphere.pos)
            vt2 = vector(obj_list[0].obj.pos[0])
            vt3 = vector(obj_list[1].obj.pos[0])
            len1 = (vt1 - vt2).mag
            len2 = (vt1 - vt3).mag
            if len1 <= len2:
                pts_list[0].set_frame(f1)
            else:
                pts_list[0].set_frame(f2)
            # }
            # для второй {
            vt1 = vector(pts_list[1].sphere.pos)
            vt2 = vector(obj_list[0].obj.pos[0])
            vt3 = vector(obj_list[1].obj.pos[0])
            len1 = (vt1 - vt2).mag
            len2 = (vt1 - vt3).mag
            if len1 <= len2:
                pts_list[1].set_frame(f1)
            else:
                pts_list[1].set_frame(f2)
            # }
            obj_list[0].obj.frame = f1
            obj_list[1].obj.frame = f2
            center1 = f1.frame_to_world(obj_list[0].obj.pos[0])
            center_ax1 = f1.frame_to_world(obj_list[0].obj.pos[1]) - f1.frame_to_world(obj_list[0].obj.pos[0])
            center2 = f2.frame_to_world(obj_list[1].obj.pos[0])
            center_ax2 = f2.frame_to_world(obj_list[1].obj.pos[1]) - f2.frame_to_world(obj_list[1].obj.pos[0])

            sim_started = True

        #elif aprox_eq(init_p1, f1.frame_to_world(pts_list[0].sphere.pos)) and aprox_eq(init_p2, pts_list[0].sphere.pos) and some_flag:
        elif sim_counter == 360:
            mode_sim_active = False
            mode_print_result = True
            title.text = u"Результат: %2.2f" %minimum
            print minimum
        else:
            if not some_flag:
                if delta > 0.01:
                    some_flag = True
                else:
                    delta += 0.0001
            #v0 = v0.rotate(angle = radians(1))
            #v1 = v0.rotate(angle = radians(3))
            #obj_list[0].obj.up = v0
            #obj_list[1].obj.up = v1

            vlen_prep1 = vector(f1.frame_to_world(pts_list[0].sphere.pos))
            vlen_prep2 = vector(f2.frame_to_world(pts_list[1].sphere.pos))
            vlen = (vlen_prep1 - vlen_prep2).mag
            if vlen < minimum:
                minimum = vlen

            # крутим точки и шестерни
            f1.rotate(angle = radians(1), axis = center_ax1, origin = center1)
            f2.rotate(angle = radians(3), axis = center_ax2, origin = center2)

            # рисуем линию между ними {
            if draw_len_line:
                try:
                #    len_label.visible = False
                #    del len_label
                    len_line.visible = False
                    del len_line
                except Exception:
                    pass
                for i in f1.objects:
                    if i == pts_list[0].sphere:
                        start_pt = f1.frame_to_world(pts_list[0].sphere.pos)
                    elif i == pts_list[1].sphere:
                        end_pt = f1.frame_to_world(pts_list[1].sphere.pos)
                for i in f2.objects:
                    if i == pts_list[0].sphere:
                        start_pt = f2.frame_to_world(pts_list[0].sphere.pos)
                    elif i == pts_list[1].sphere:
                        end_pt = f2.frame_to_world(pts_list[1].sphere.pos)
                #start_pt = f1.frame_to_world(pts_list[0].sphere.pos)
                #end_pt   = f2.frame_to_world(pts_list[1].sphere.pos)
                #l_pos = start_pt
                len_line = curve(pos = [start_pt, end_pt], radius = 0.1, color = color.yellow)
                #len_label = label(pos = l_pos, xoffset = 0.5, y_offset = 0.5, line = True, text = "%2.4f" %vlen)
            # }
            sim_counter += 1
            #mode_rotate_obj = True
