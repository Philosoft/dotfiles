# -*-  coding: utf-8 -*-

import pygtk
pygtk.require('2.0')
import gtk
from time import time
import sqlite3
import os
from alphabet import transfer_dict, readable_t_dict, readable_o_dict
from matplotlib.figure import Figure
from matplotlib.backends.backend_gtkagg import FigureCanvasGTKAgg as FigureCanvas
from matplotlib.backends.backend_gtkagg import NavigationToolbar2GTKAgg as NavigationToolbar
from matplotlib import interactive

interactive(True)
counter = 0
one_letter_dict = {
        'Cyrillic_a': [],
        'Cyrillic_be': [],
        'Cyrillic_ve': [],
        'Cyrillic_ghe': [],
        'Cyrillic_de': [],
        'Cyrillic_ie': [],
        'Cyrillic_io': [],
        'Cyrillic_zhe': [],
        'Cyrillic_ze': [],
        'Cyrillic_i': [],
        'Cyrillic_shorti': [],
        'Cyrillic_ka': [],
        'Cyrillic_el': [],
        'Cyrillic_em': [],
        'Cyrillic_en': [],
        'Cyrillic_o': [],
        'Cyrillic_pe': [],
        'Cyrillic_er': [],
        'Cyrillic_es': [],
        'Cyrillic_te': [],
        'Cyrillic_u': [],
        'Cyrillic_ef': [],
        'Cyrillic_ha': [],
        'Cyrillic_tse': [],
        'Cyrillic_che': [],
        'Cyrillic_sha': [],
        'Cyrillic_shcha': [],
        'Cyrillic_softsign': [],
        'Cyrillic_yeru': [],
        'Cyrillic_hardsign': [],
        'Cyrillic_e': [],
        'Cyrillic_yu': [],
        'Cyrillic_ya': [],
        'space': [],
        'period': [],
        'comma': []
}

tv_ud = None
tv_pr = None
sw_ud = None
sw_pr = None
epsilon = 0.5

VALID_KEYVALS = [1729, 1730, 1751, 1735, 1732,
                 1733, 1699, 1750, 1754, 1754,
                 1737, 1738, 1739, 1740, 1741,
                 1742, 1743, 1744, 1746, 1747,
                 1748, 1749, 1734, 1736, 1731,
                 1758, 1755, 1757, 1752, 1753,
                 1759, 1756, 1728, 1745, 32,
                 44, 46,]


def clear_one_l_dict():
    global one_letter_dict
    for i in one_letter_dict.iterkeys():
        one_letter_dict[i] = []

def clear_transfer_dict():
    global transfer_dict
    for i in transfer_dict.iterkeys():
        transfer_dict[i] = []


class App(gtk.Builder):
    '''no desc'''
    def __init__(self):
        super(App, self).__init__()
        self.add_from_file('gui.ui')
        self.connect_signals(self)
        self.window1.connect('destroy', lambda x: gtk.main_quit())

        self.buf = ''
        self.tbuf = self.textview1.get_buffer()

        self.entry_username.set_text('phil')

        # prefs {
        self.entry_epsilon_add.set_text('0.2')
        self.entry_epsilon_mult.set_text('0.8')
        self.entry_amax.set_text('20')
        self.entry_mmax.set_text('20')
        # }

        # graphs {
        self.fig_ud = Figure(figsize = (5, 4), dpi = 96)
        self.canvas_ud = FigureCanvas(self.fig_ud)
        self.vbox6.pack_start(self.canvas_ud, True, True, 0)
        self.toolbar_ud = NavigationToolbar(self.canvas_ud, self.window1)
        self.vbox6.pack_start(self.toolbar_ud, False, False)

        self.fig_pr = Figure(figsize = (5, 4), dpi = 96)
        self.canvas_pr = FigureCanvas(self.fig_pr)
        self.vbox7.pack_start(self.canvas_pr, True, True)
        self.toolbar_pr = NavigationToolbar(self.canvas_pr, self.window1)
        self.vbox7.pack_start(self.toolbar_pr, False, False)

        self.fig_ud_mult = Figure(figsize = (5, 4), dpi = 96)
        self.canvas_ud_mult = FigureCanvas(self.fig_ud_mult)
        self.vbox8.pack_start(self.canvas_ud_mult, True, True)
        self.toolbar_ud_mult = NavigationToolbar(self.canvas_ud_mult, self.window1)
        self.vbox8.pack_start(self.toolbar_ud_mult, False, False)

        self.fig_pr_mult = Figure(figsize = (5, 4), dpi = 96)
        self.canvas_pr_mult = FigureCanvas(self.fig_pr_mult)
        self.vbox9.pack_start(self.canvas_pr_mult, True, True)
        self.toolbar_pr_mult = NavigationToolbar(self.canvas_pr_mult, self.window1)
        self.vbox9.pack_start(self.toolbar_pr_mult, False, False)
        # }

        # удержание {
        self.flag_one = True
        self.time_press = 0
        self.time_release = 0
        # }
        # переход {
        self.time_tr_begin = 0
        self.time_tr_end = 0
        self.flag_tr = False
        self.first_time_flag = True #FIXME не забыть обновлять это дело при каждом заходе
        self.first_char = ''
        self.second_char = ''
        # }

        self.window1.show_all()
        gtk.main()

    def __getattr__(self, attr):
        obj = self.get_object(attr)
        if not obj:
            raise AttributeError('There are no such attr as `' + attr + '\'')
        setattr(self, attr, obj)
        return obj

    def key_press_cb(self, widget, event):
        '''Обрабатываем событие: нажатие клавиши'''
        if event.keyval in VALID_KEYVALS:
            self.time_press = time()
            # переход {
            if self.flag_tr:
                self.flag_tr = False
                self.second_char = str(gtk.gdk.keyval_name(event.keyval))
                time_tr = self.time_press - self.time_tr_begin
                transfer_dict[self.first_char + self.second_char].append(time_tr)
                self.first_char = self.second_char
                self.second_char = ''
            else:
            # }
            # удержание {
                self.first_char = str(gtk.gdk.keyval_name(event.keyval))
            # }

    def key_release_cb(self, widget, event):
        '''Обрабатываем событие: клавиша отпущена'''
        if event.keyval in VALID_KEYVALS:
            # переход {
            self.time_tr_begin = time()
            self.flag_tr = True
            # }

            # удержание {
            # время, когда отпустили клавишу
            result = self.time_tr_begin - self.time_press
            one_letter_dict[gtk.gdk.keyval_name(event.keyval)].append(result)
            # }

    def print_dict(self):
        '''DEBUG: распечатываем словарик'''
        for i in one_letter_dict.iterkeys():
            loc_sum = 0
            loc_len = len(one_letter_dict[i])
            if loc_len > 0:
                for t in one_letter_dict[i]:
                    loc_sum += t
                avr = loc_sum / loc_len
                print '===', i, '==='
                print '::', one_letter_dict[i]
                print '::', 'len =', loc_len
                print '::', 'avr =', str(avr)[:5]

        for i in transfer_dict.iterkeys():
            loc_sum = 0
            loc_len = len(transfer_dict[i])
            if loc_len > 0:
                for t in transfer_dict[i]:
                    loc_sum += t
                avr = loc_sum / loc_len
                print readable_t_dict[i], ':', loc_len

    def register_it(self, widget):
        '''Запоминаем почерк в базе'''
        self.processing_data()
        self.write_to_base()
        self.info_dialog('У нас всё записано')

    def check_it(self, widget):
        '''Проверяем почерк'''
        try:
            self.label_result.set_text('Работаем…')
            self.fill_tables()
            self.flag_tr = False
            global one_letter_dict
            global transfer_dict
            tmp_ud_dict = one_letter_dict.copy()
            tmp_pr_dict = transfer_dict.copy()
            self.label_result.set_text('')
            self.mul_check()
            one_letter_dict = tmp_ud_dict.copy()
            transfer_dict = tmp_pr_dict.copy()
            self.add_check()
            clear_one_l_dict()
            clear_transfer_dict()
            self.flag_tr = False
        except Exception as e:
            print str(e)
            clear_one_l_dict() #FIXME: перерисовать график в любом случае
            clear_transfer_dict()
            self.flag_tr = False

    def replace_db(self, widget):
        '''Перезаписываем базу'''
        self.processing_data()
        self.write_to_base()

    def processing_data(self):
        '''Подготавливаем данные для записи в базу'''
        for i in one_letter_dict.iterkeys():
            loc_sum = 0
            loc_avr = 0
            loc_len = len(one_letter_dict[i])
            if loc_len > 0:
                for t in one_letter_dict[i]:
                    loc_sum += t
                loc_avr = loc_sum / loc_len
            one_letter_dict[i] = loc_avr
        for i in transfer_dict.iterkeys():
            loc_sum = 0
            loc_avr = 0
            loc_len = len(transfer_dict[i])
            if loc_len > 0:
                for t in transfer_dict[i]:
                    loc_sum += t
                loc_avr = loc_sum / loc_len
            transfer_dict[i] = loc_avr

    def write_to_base(self):
        user = self.entry_username.get_text()
        if user == '':
            user = 'username'
            self.entry_username.set_text('username')
        conn = sqlite3.connect('./' + user + '.sqlite')
        c = conn.cursor()
        try:
            c.execute('create table t_ud (keyname text, t real)')
            c.execute('create table t_pr (leyname text, t real)')
        except Exception as e:
            # плевать
            pass
        for vals in one_letter_dict.items():
            c.execute('insert into t_ud values (?,?)', vals)
        for vals in transfer_dict.items():
            c.execute('insert into t_pr values (?,?)', vals)
        conn.commit()
        c.close()

        clear_one_l_dict()
        clear_transfer_dict()

    def load_from_base(self):
        user = self.entry_username.get_text()
        print 'username = ***', user, '***'
        if user == '':
            user = 'phil'
            self.entry_username.set_text(user)
        if not os.path.exists('./' + user + '.sqlite'):
            print '*** ololo ***'
            return
        conn = sqlite3.connect('./' + user + '.sqlite')
        c = conn.cursor()
        for keyname, t in c.execute('select * from t_ud').fetchall():
            one_letter_dict[keyname] = t
        for keyname, t in c.execute('select * from t_pr').fetchall():
            transfer_dict[keyname] = t
        c.close()

    def info_dialog(self, msg):
        d = gtk.MessageDialog(self.window1, gtk.DIALOG_DESTROY_WITH_PARENT, gtk.MESSAGE_INFO, gtk.BUTTONS_OK, msg)
        d.run()
        d.destroy()

    def add_check(self):
        '''Аддитивный фильтр'''
        t_ud = one_letter_dict.copy()
        t_pr = transfer_dict.copy()
        self.load_from_base()

        # удержания {
        a_dict = one_letter_dict.copy()
        for i in a_dict.iterkeys():
            a_dict[i] = []

        k_ud = 0
        N_ud = 0
        for i in t_ud.iterkeys():
            loc_len = len(t_ud[i])
            if loc_len > 0 and one_letter_dict[i] > 0:
                N_ud += loc_len
                for t in t_ud[i]:
                    a_dict[i].append(t - one_letter_dict[i])
                    epsilon = float(self.entry_epsilon_add.get_text())
                    if t > one_letter_dict[i] + epsilon or t < one_letter_dict[i] - epsilon:
                        k_ud += 1
        # }

        # { переходы
        k_pr = 0
        N_pr = 0
        a_pr_dict = transfer_dict.copy()
        for i in a_pr_dict.iterkeys():
            a_pr_dict[i] = []

        for i in t_pr.iterkeys():
            loc_len = len(t_pr[i])
            if loc_len > 0 and transfer_dict[i] > 0:
                N_pr += loc_len
                for t in t_pr[i]:
                    cur_t = t - transfer_dict[i]
                    a_pr_dict[i].append(cur_t)
                    epsilon = float(self.entry_epsilon_add.get_text())
                    if cur_t > transfer_dict[i] + epsilon or cur_t < transfer_dict[i] - epsilon:
                        k_pr += 1
        # }
        #print 'N_ud =', N_ud, 'k_ud =', k_ud, 'N / k =', float(k_ud) / float(N_ud)
        #print 'N_pr =', N_pr, 'k_pr =', k_pr, 'N / k =', float(k_pr) / float(N_pr)
        # вердикт по этому фильтру
        #print self.entry_amax.get_text()
        if float(k_ud + k_pr) / float(N_ud + N_pr) <= float(self.entry_amax.get_text()) / 100.0:
            buf = self.label_result.get_text()
            buf += ' Аддитивный: ✔ '
            self.label_result.set_text(buf)
        else:
            buf = self.label_result.get_text()
            buf += ' Аддитивный: x '
            self.label_result.set_text(buf)

        self.plot_graphs(self.fig_ud, self.fig_pr, ud_dict = a_dict, pr_dict = a_pr_dict, epsilon = epsilon)

    def mul_check(self):
        '''Мыльтипликативный фильтр'''
        t_ud = one_letter_dict.copy()
        t_pr = transfer_dict.copy()
        self.load_from_base()

        epsilon = float(self.entry_epsilon_mult.get_text())

        # удержания {
        m_dict = one_letter_dict.copy()
        for i in m_dict.iterkeys():
            m_dict[i] = []

        k_ud = 0
        N_ud = 0
        for i in t_ud.iterkeys():
            loc_len = len(t_ud[i])
            if loc_len > 0 and one_letter_dict[i] > 0:
                N_ud += loc_len
                for t in t_ud[i]:
                    cur_val = t / one_letter_dict[i]
                    m_dict[i].append(cur_val)
                    if cur_val < one_letter_dict[i] + epsilon and cur_val > one_letter_dict[i] + epsilon:
                        pass
                    else:
                        k_ud += 1
        # }
        # { по переходам
        N_pr = 0
        k_pr = 0
        m_pr_dict = transfer_dict.copy()
        for i in m_pr_dict.iterkeys():
            m_pr_dict[i] = []

        for i in t_pr.iterkeys():
            loc_len = len(t_pr[i])
            if loc_len > 0 and transfer_dict[i] > 0:
                N_pr += loc_len
                for t in t_pr[i]:
                    cur_val = t / transfer_dict[i]
                    m_pr_dict[i].append(cur_val)
                    if cur_val < transfer_dict[i] + epsilon and cur_val > transfer_dict[i] - epsilon:
                        pass
                    else:
                        k_pr += 1
        # }
        self.plot_graphs(ud_dict = m_dict, pr_dict = m_pr_dict, epsilon = epsilon, is_mult = True,
                    ud_fig = self.fig_ud_mult, pr_fig = self.fig_pr_mult)
        #print 'N_ud =', N_ud, 'k_ud =', k_ud, 'N / k =', float(k_ud) / float(N_ud)
        #print 'N_pr =', N_pr, 'k_pr =', k_pr, 'N / k =', float(k_pr) / float(N_pr)
        # вердикт по этому фильтру
        if float(k_ud + k_pr) / float(N_ud + N_pr) <= float(self.entry_mmax.get_text()) / 100.0:
            buf = self.label_result.get_text()
            buf += ' Мультипликаитвный: ✔ '
            self.label_result.set_text(buf)
        else:
            buf = self.label_result.get_text()
            buf += ' Мультипликативный: x '
            self.label_result.set_text(buf)

    def plot_graphs(self,
                    ud_fig,
                    pr_fig,
                    ud_dict = one_letter_dict,
                    pr_dict = transfer_dict,
                    epsilon = 0.2,
                    is_mult = False
                   ):
        '''Рисовать графики.
            @params:
                ud_dict - словарь удержаний
                pr_dict - словарь переходов
                ud_fig
                pr_fig'''
        ud_fig.clf()
        pr_fig.clf()
        ax_ud = ud_fig.add_subplot(111)

        char = 0
        t_list = []
        c_list = []
        for i in ud_dict.iterkeys():
            char += 1
            if len(ud_dict[i]) > 0:
                for t in ud_dict[i]:
                    t_list.append(t)
                    c_list.append(char)

        ax_ud.scatter(c_list, t_list)
        t_list = []
        for i in c_list:
            if is_mult:
                t_list.append(1 + epsilon)
            else:
                t_list.append(epsilon)

        ax_ud.plot(c_list, t_list, 'r')
        t_list = []
        epsilon = -epsilon
        for i in c_list:
            if is_mult:
                t_list.append(1 + epsilon)
            else:
                t_list.append(epsilon)

        ax_ud.plot(c_list, t_list, 'r')
        ax_ud.set_title('Hold')
        ax_ud.grid(which='both')
        ud_fig.canvas.draw()

        # { переход
        ax_pr = pr_fig.add_subplot(111)

        char = 0
        t_list = []
        c_list = []
        for i in pr_dict.iterkeys():
            char += 1
            if len(pr_dict[i]) > 0:
                for t in pr_dict[i]:
                    t_list.append(t)
                    c_list.append(char)
        ax_pr.scatter(c_list, t_list)
        t_list = []
        for i in c_list:
            if is_mult:
                t_list.append(1 + epsilon)
            else:
                t_list.append(epsilon)

        ax_pr.plot(c_list, t_list, 'r')
        t_list = []
        epsilon = -epsilon
        for i in c_list:
            if is_mult:
                t_list.append(1 + epsilon)
            else:
                t_list.append(epsilon)

        ax_pr.plot(c_list, t_list, 'r')
        ax_pr.set_title('Transfer')
        ax_pr.grid(which='both')
        pr_fig.canvas.draw()
        # }

    def fill_tables(self):
        # { время удержания
        # получим наибольшее количество нажатий для определения величины хранилища
        global tv_ud
        global tv_pr
        global sw_ud
        global sw_pr
        max_len = 1
        cur_len = 0
        try:
            for i in one_letter_dict.iterkeys():
                cur_len = len(one_letter_dict[i])
                if cur_len > max_len:
                    max_len = cur_len
        except TypeError as e:
            print 'ALARM' #FIXME float dict

        store_tud = None
        future_code = 'gtk.ListStore(str, '
        for i in range(max_len - 1):
            future_code += 'str, '
        future_code += 'str)'
        store_tud = eval(future_code)

        for i in one_letter_dict.iterkeys():
            cur_pos = 0
            if len(one_letter_dict[i]) > 0:
                tmp_list = [readable_o_dict[i]]
                try:
                    for j in one_letter_dict[i]:
                        tmp_list.append(str(j)[:5])
                        cur_pos += 1
                    while cur_pos < max_len:
                        tmp_list.append('0')
                        cur_pos += 1
                except TypeError as e:
                    tmp_list.append(str(one_letter_dict[i])[:5])
                store_tud.append(tmp_list)

        if tv_ud != None:
            tv_ud.destroy()
        tv_ud = gtk.TreeView(store_tud)
        rendererText = gtk.CellRendererText()
        col = gtk.TreeViewColumn('Буква', rendererText, text = 0)
        col.set_sort_column_id(0)
        tv_ud.append_column(col)
        for i in range(max_len):
            rendererText = gtk.CellRendererText()
            column = gtk.TreeViewColumn('t' + str(i), gtk.CellRendererText(), text=i+1)
            column.set_sort_column_id(i + 1)
            tv_ud.append_column(column)

        if sw_ud == None:
            sw_ud = gtk.ScrolledWindow()
            sw_ud.set_shadow_type(gtk.SHADOW_ETCHED_IN)
            sw_ud.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
            self.vbox4.pack_start(sw_ud, True, True, 0)
        sw_ud.add(tv_ud)
        # }
        # { t_pr
        max_len = 1
        for i in transfer_dict.iterkeys():
            try:
                cur_len = len(transfer_dict[i])
                if cur_len > max_len:
                    max_len = cur_len
            except Exception as e:
                pass
        store_pr = None
        future_code = 'gtk.ListStore(str, '
        for i in range(max_len - 1):
            future_code += 'str, '
        future_code += 'str)'
        store_pr = eval(future_code)
        for i in transfer_dict.iterkeys():
            cur_pos = 0
            if len(transfer_dict[i]) > 0:
                tmp_list = [readable_t_dict[i]]
                try:
                    for j in transfer_dict[i]:
                        tmp_list.append(str(j)[:5])
                        cur_pos += 1
                    while cur_pos != max_len:
                        tmp_list.append('0')
                        cur_pos += 1
                except TypeError as e:
                    tmp_list.append(str(transfer_dict[i])[:5])
                store_pr.append(tmp_list)

        if tv_pr != None:
            tv_pr.destroy()
        tv_pr = gtk.TreeView(store_pr)
        rendererText = gtk.CellRendererText()
        col = gtk.TreeViewColumn('Буква', rendererText, text = 0)
        col.set_sort_column_id(0)
        tv_pr.append_column(col)
        for i in range(max_len):
            rendererText = gtk.CellRendererText()
            column = gtk.TreeViewColumn('t' + str(i), rendererText, text=i+1)
            column.set_sort_column_id(i + 1)
            tv_pr.append_column(column)

        if sw_pr != None:
            sw_pr.destroy()
        sw_pr = gtk.ScrolledWindow()
        sw_pr.set_shadow_type(gtk.SHADOW_ETCHED_IN)
        sw_pr.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
        self.vbox5.pack_start(sw_pr, True, True, 0)
        sw_pr.add(tv_pr)
        # }
        self.window1.show_all()


if __name__ == '__main__':
    dummy = App()
