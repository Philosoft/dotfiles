#!/usr/bin/python
# -*- coding: utf-8 -*-

import pygtk
pygtk.require('2.0')
import gtk
from math import sqrt
from time import sleep

from array import array
from struct import unpack, pack

import pyaudio
import wave

from threading import Thread

from matplotlib.figure import Figure
from matplotlib.backends.backend_gtkagg import FigureCanvasGTKAgg as FigureCanvas
from matplotlib.backends.backend_gtkagg import NavigationToolbar2GTKAgg as NavigationToolbar
from numpy import pi, cos, polyfit
from matplotlib import interactive

import matplotlib.tight_layout

import matplotlib as mpl
mpl.rcParams['font.size'] = 10


interactive(True)

# Audio code {
THRESHOLD = 500
CHUNK_SIZE = 1024
FORMAT = pyaudio.paInt16
RATE = 44100

class Recorder(Thread):
    def __init__(self):
        super(Recorder, self).__init__()
        self.do_flag = True
        self.snd_started = False

    def stop(self):
        print ':: Recorder.stop'
        self.do_flag = False

    def run(self):
        print ':: Recorder.start'
        self.record_to_file('user.wav')

    def is_silent(self, L):
        "Returns `True` if below the 'silent' threshold"
        return max(L) < THRESHOLD

    def normalize(self, L):
        "Average the volume out"
        MAXIMUM = 16384
        times = float(MAXIMUM)/max(abs(i) for i in L)

        LRtn = array('h')
        for i in L:
            LRtn.append(int(i*times))
        return LRtn

    def trim(self, L):
        "Trim the blank spots at the start and end"
        def _trim(L):
            self.snd_started = False
            LRtn = array('h')

            for i in L:
                if not self.snd_started and abs(i)>THRESHOLD:
                    self.snd_started = True
                    LRtn.append(i)

                elif self.snd_started:
                    LRtn.append(i)
            return LRtn

        # Trim to the left
        L = _trim(L)

        # Trim to the right
        L.reverse()
        L = _trim(L)
        L.reverse()

        return L

    def add_silence(self, L, seconds):
        "Add silence to the start and end of `L` of length `seconds` (float)"
        LRtn = array('h', [0 for i in xrange(int(seconds*RATE))])
        LRtn.extend(L)
        LRtn.extend([0 for i in xrange(int(seconds*RATE))])
        return LRtn

    def record(self):
        """
        Record a word or words from the microphone and
        return the data as an array of signed shorts.

        Normalizes the audio, trims silence from the
        start and end, and pads with 0.5 seconds of
        blank sound to make sure VLC et al can play
        it without getting chopped off.
        """
        print '::   starting'
        print '::   `-', self.do_flag
        p = pyaudio.PyAudio()
        stream = p.open(format=FORMAT, channels=1, rate=RATE,
                        input=True, output=True,
                        frames_per_buffer=CHUNK_SIZE)

        self.snd_started = False

        LRtn = array('h')

        print '::   magic cycle'
        while self.do_flag:
            if not self.snd_started:
                self.snd_started = True
            data = stream.read(CHUNK_SIZE)
            L = unpack('<' + ('h'*(len(data)/2)), data) # little endian, signed short
            L = array('h', L)
            LRtn.extend(L)

            silent = self.is_silent(L)

        print '::  stoping'
        sample_width = p.get_sample_size(FORMAT)
        stream.stop_stream()
        stream.close()
        p.terminate()

        #LRtn = self.normalize(LRtn)
        #LRtn = self.trim(LRtn)
        #LRtn = self.add_silence(LRtn, 0.5)
        return sample_width, LRtn

    def record_to_file(self, path):
        "Records from the microphone and outputs the resulting data to `path`"
        sample_width, data = self.record()
        data = pack('<' + ('h'*len(data)), *data)

        wf = wave.open(path, 'wb')
        wf.setnchannels(1)
        wf.setsampwidth(sample_width)
        wf.setframerate(RATE)
        wf.writeframes(data)
        wf.close()
# }

def coefs_to_str(arr):
    buf = ''
    for i in arr:
        buf += '  %2.4f\n' %(i)
    return buf

def plot_plot(path):
    f = wave.open(path, 'r')
    result = []
    for i in range(f.getnframes()):
        result.append(unpack('h', f.readframes(1)))
    result = filter(lambda x: abs(x[0]) > 300, result)
    arr = result[2000:]
    arr = result[:2000]
    arr_x = range(2000, len(arr) + 2000)
    avr = float(sum(map(lambda x: x[0], result))) / (len(result))
    deviation = sqrt(1.0 / (len(result) - 1.0) * sum(map(lambda x: (x[0] - avr)**2, result)))
    coefs = polyfit(arr_x, arr, 3)
    return range(len(result)), result, avr, deviation, coefs


class App(gtk.Builder):
    def __init__(self):
        super(App, self).__init__()
        self.add_from_file('gui.ui')
        self.connect_signals(self)
        self.window1.connect('destroy', lambda x: gtk.main_quit())

        self.fig = Figure(figsize = (5,4), dpi = 100)
        self.canvas = FigureCanvas(self.fig)
        self.vbox1.pack_start(self.canvas)
        self.toolbar = NavigationToolbar(self.canvas, self.window1)
        self.vbox1.pack_start(self.toolbar, False, False)

        self.ax = self.fig.add_subplot(111)
        self.ax.grid()
        self.fig.canvas.draw()

        # 4 comparsion
        self.fig_cmp = Figure(figsize = (5,4), dpi = 100)
        self.canvas_cmp = FigureCanvas(self.fig_cmp)
        self.vbox1.pack_start(self.canvas_cmp)
        self.toolbar_cmp = NavigationToolbar(self.canvas_cmp, self.window1)
        self.vbox1.pack_start(self.toolbar_cmp, False, False)

        # Создание буферов для базы {
        self.tbuf1 = self.textview1.get_buffer()
        self.tbuf2 = self.textview2.get_buffer()
        self.tbuf3 = self.textview3.get_buffer()
        self.tbuf4 = self.textview4.get_buffer()
        self.tbuf5 = self.textview5.get_buffer()
        self.tbuf6 = self.textview6.get_buffer()
        # }

        base_buf = ''
        self.base_info = []


        # Создание мест для графиков из базы {
        self.fig_base2 = Figure(figsize = (5,4), dpi = 100)
        self.canvas_base2 = FigureCanvas(self.fig_base2)
        self.hbox2.pack_start(self.canvas_base2)

        self.ax_base2 = self.fig_base2.add_subplot(111)
        arr_x, arr_y, avr, deviation, coefs = plot_plot('user1.wav')
        base_buf = '%f\n%s\n' %(deviation, coefs_to_str(coefs))
        self.tbuf1.set_text('d=%2.4f\n%s' %(deviation, coefs_to_str(coefs)) )
        self.base_info.append([avr, deviation, coefs])
        self.ax_base2.plot(arr_x, arr_y)
        self.ax_base2.grid()
        self.fig_base2.canvas.draw()

        self.fig_base3 = Figure(figsize = (5,4), dpi = 100)
        self.canvas_base3 = FigureCanvas(self.fig_base3)
        self.hbox3.pack_start(self.canvas_base3)

        self.ax_base3 = self.fig_base3.add_subplot(111)
        arr_x, arr_y, avr, deviation, coefs = plot_plot('user2.wav')
        self.tbuf2.set_text('d=%2.4f\n%s' %(deviation, coefs_to_str(coefs)) )
        base_buf += '%f\n%s\n' %(deviation, coefs_to_str(coefs))
        self.base_info.append([avr, deviation, coefs])
        self.ax_base3.plot(arr_x, arr_y)
        self.ax_base3.grid()
        self.fig_base3.canvas.draw()

        self.fig_base4 = Figure(figsize = (5,4), dpi = 100)
        self.canvas_base4 = FigureCanvas(self.fig_base4)
        self.hbox4.pack_start(self.canvas_base4)

        self.ax_base4 = self.fig_base4.add_subplot(111)
        arr_x, arr_y, avr, deviation, coefs = plot_plot('user3.wav')
        base_buf += '%f\n%s\n' %(deviation, coefs_to_str(coefs))
        self.tbuf3.set_text('d=%2.4f\n%s' %(deviation, coefs_to_str(coefs)) )
        self.base_info.append([avr, deviation, coefs])
        self.ax_base4.plot(arr_x, arr_y)
        self.ax_base4.grid()

        self.fig_base5 = Figure(figsize = (5,4), dpi = 100)
        self.canvas_base5 = FigureCanvas(self.fig_base5)
        self.hbox5.pack_start(self.canvas_base5)

        self.ax_base5 = self.fig_base5.add_subplot(111)
        arr_x, arr_y, avr, deviation, coefs = plot_plot('user4.wav')
        base_buf += '%f\n%s\n' %(deviation, coefs_to_str(coefs))
        self.tbuf4.set_text('d=%2.4f\n%s' %(deviation, coefs_to_str(coefs)) )
        self.base_info.append([avr, deviation, coefs])
        self.ax_base5.plot(arr_x, arr_y)
        self.ax_base5.grid()

        self.fig_base6 = Figure(figsize = (5,4), dpi = 100)
        self.canvas_base6 = FigureCanvas(self.fig_base6)
        self.hbox6.pack_start(self.canvas_base6)

        self.ax_base6 = self.fig_base6.add_subplot(111)
        arr_x, arr_y, avr, deviation, coefs = plot_plot('user5.wav')
        base_buf += '%f\n%s\n' %(deviation, coefs_to_str(coefs))
        self.base_info.append([avr, deviation, coefs])
        self.tbuf5.set_text('d=%2.4f\n%s' %(deviation, coefs_to_str(coefs)) )
        self.ax_base6.plot(arr_x, arr_y)
        self.ax_base6.grid()
        # }


        self.recorder = Recorder()

        self.is_recording = False
        self.window1.show_all()
        gtk.main()

    def __getattr__(self, attr):
        obj = self.get_object(attr)
        if not obj:
            raise AttributeError('There are no such attr as `' + attr + '\'')
        setattr(self, attr, obj)
        return obj

    def start_rec(self):
        gtk.gdk.threads_init()
        self.recorder = Recorder()
        gtk.threads_enter()
        self.recorder.start()
        gtk.threads_leave()

    def stop_rec(self):
        self.recorder.stop()
        del self.recorder

    def update_info(self):
        # graph{
        self.fig.clf()
        arr = []
        f = wave.open('user.wav', 'r')
        for i in range(f.getnframes()):
            arr.append(unpack('h', f.readframes(1)))

        self.ax = self.fig.add_subplot(111)
        self.ax.grid()
        arr = filter(lambda x: abs(x[0]) > 200, arr)
        self.ax.plot(range(len(arr)), arr)
        self.fig.canvas.draw()
        # }

        # text info {
        self.txt_buf = ''
        avr = float(sum(map(lambda x: x[0], arr))) / float(len(arr))
        deviation = sqrt(1.0 / (len(arr) - 1.0) * sum(map(lambda x: (x[0] - avr)**2, arr)))
        self.txt_buf = 'd = %2.4f\n' %(deviation)
        arr = arr[2000:]
        arr = arr[:2000]
        arr_x = range(2000, len(arr) + 2000)
        coefs = polyfit(arr_x, arr, 3)
        self.txt_buf += 'coefs = \n%s' %(coefs_to_str(coefs))
        self.tbuf6.set_text(self.txt_buf)
        func = lambda x: coefs[0] * x**3 + coefs[1] * x**2 + coefs[2] * x + coefs[3]
        self.ax = self.fig.add_subplot(111)
        self.ax.plot(arr_x, map(lambda x: x[0], arr))
        self.fig.canvas.draw()
        self.ax.grid()

        self.check(avr, deviation, coefs)
        # }

    def criter(self, crit, crit_sample):
        crit = round(crit, 4)
        crit_sample = round(crit_sample, 4)
        print ' ==> Comparing %f and %f' %(crit, crit_sample)
        if crit >= crit_sample * 0.4 and crit <= crit_sample*1.6:
            print ' ===> y'
            return True
        else:
            print ' ===> n'
            return False


    def check(self, avr, dev, c):
        for i in range(5):
            cur_avr, cur_dev, cur_c = self.base_info[i][0], self.base_info[i][1], self.base_info[i][2]
            crit_w = 0
            #if self.criter(avr, cur_avr):
            #    crit_W += 1

            dev_flag = False
            if self.criter(dev, cur_dev):
                dev_flag = True
                print '===> dev is cmp with %i' %(i + 1)

            if dev_flag:
                for j in range(len(c)):
                    if self.criter(c[j], cur_c[j]):
                        crit_w += 1

            if dev_flag and crit_w >= 2:
                print '=====> HAVE A MATCH WITH #%i' %(i + 1)
                self.txt_buf += '\nСовпадает с голосом №%i\n' %(i + 1)
                self.txt_buf += '`-d = %2.4f\n`-coefs = \n%s\n' %(cur_dev, coefs_to_str(cur_c))
                self.tbuf6.set_text(self.txt_buf)

                arr_x, arr_y, avr, deviation, coefs = plot_plot('user%i.wav' %(i + 1))
                self.fig_cmp.clf()
                self.ax_cmp = self.fig_cmp.add_subplot(111)
                self.ax_cmp.plot(arr_x, arr_y)
                self.ax_cmp.grid()
                self.fig_cmp.canvas.draw()
                break


    def btn_clicked(self, widget):
        if self.is_recording == True:
            self.stop_rec()
            self.is_recording = False
            self.button1.set_label('Start')
            sleep(0.5)
            self.fig_cmp.clf()
            self.update_info()
        else:
            self.is_recording = True
            self.button1.set_label('Stop')
            self.start_rec()


a = App()
